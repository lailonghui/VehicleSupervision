// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"VehicleSupervision/internal/modules/device/model"
	model1 "VehicleSupervision/pkg/graphql/model"
	"fmt"
	"io"
	"strconv"
	"time"
)

// aggregated selection of "sim_card"
type SimCardAggregate struct {
	Aggregate *SimCardAggregateFields `json:"aggregate"`
	Nodes     []*model.SimCard        `json:"nodes"`
}

// aggregate fields of "sim_card"
type SimCardAggregateFields struct {
	Avg        *SimCardAvgFields        `json:"avg"`
	Count      *int                     `json:"count"`
	Max        *SimCardMaxFields        `json:"max"`
	Min        *SimCardMinFields        `json:"min"`
	Stddev     *SimCardStddevFields     `json:"stddev"`
	StddevPop  *SimCardStddevPopFields  `json:"stddev_pop"`
	StddevSamp *SimCardStddevSampFields `json:"stddev_samp"`
	Sum        *SimCardSumFields        `json:"sum"`
	VarPop     *SimCardVarPopFields     `json:"var_pop"`
	VarSamp    *SimCardVarSampFields    `json:"var_samp"`
	Variance   *SimCardVarianceFields   `json:"variance"`
}

// order by aggregate values of table "sim_card"
type SimCardAggregateOrderBy struct {
	Avg        *SimCardAvgOrderBy        `json:"avg"`
	Count      *model1.OrderBy           `json:"count"`
	Max        *SimCardMaxOrderBy        `json:"max"`
	Min        *SimCardMinOrderBy        `json:"min"`
	Stddev     *SimCardStddevOrderBy     `json:"stddev"`
	StddevPop  *SimCardStddevPopOrderBy  `json:"stddev_pop"`
	StddevSamp *SimCardStddevSampOrderBy `json:"stddev_samp"`
	Sum        *SimCardSumOrderBy        `json:"sum"`
	VarPop     *SimCardVarPopOrderBy     `json:"var_pop"`
	VarSamp    *SimCardVarSampOrderBy    `json:"var_samp"`
	Variance   *SimCardVarianceOrderBy   `json:"variance"`
}

// input type for inserting array relation for remote table "sim_card"
type SimCardArrRelInsertInput struct {
	Data       []*SimCardInsertInput `json:"data"`
	OnConflict *SimCardOnConflict    `json:"on_conflict"`
}

// aggregate avg on columns
type SimCardAvgFields struct {
	ID         *float64 `json:"id"`
	MobileType *float64 `json:"mobile_type"`
}

// order by avg() on columns of table "sim_card"
type SimCardAvgOrderBy struct {
	ID         *model1.OrderBy `json:"id"`
	MobileType *model1.OrderBy `json:"mobile_type"`
}

// Boolean expression to filter rows from the table "sim_card". All fields are combined with a logical 'AND'.
type SimCardBoolExp struct {
	And         []*SimCardBoolExp                `json:"_and"`
	Not         *SimCardBoolExp                  `json:"_not"`
	Or          []*SimCardBoolExp                `json:"_or"`
	CreateAt    *model1.TimestamptzComparisonExp `json:"create_at"`
	CreateBy    *model1.StringComparisonExp      `json:"create_by"`
	DeleteAt    *model1.TimestamptzComparisonExp `json:"delete_at"`
	DeleteBy    *model1.StringComparisonExp      `json:"delete_by"`
	DeptID      *model1.StringComparisonExp      `json:"dept_id"`
	ID          *model1.BigintComparisonExp      `json:"id"`
	IsDelete    *model1.BooleanComparisonExp     `json:"is_delete"`
	MobileType  *model1.IntComparisonExp         `json:"mobile_type"`
	OperatorsID *model1.StringComparisonExp      `json:"operators_id"`
	ProxyrgID   *model1.StringComparisonExp      `json:"proxyrg_id"`
	Remark      *model1.StringComparisonExp      `json:"remark"`
	SimCardID   *model1.StringComparisonExp      `json:"sim_card_id"`
	SimNumber   *model1.StringComparisonExp      `json:"sim_number"`
	TerminalID  *model1.StringComparisonExp      `json:"terminal_id"`
	UpdateAt    *model1.TimestamptzComparisonExp `json:"update_at"`
	UpdateBy    *model1.StringComparisonExp      `json:"update_by"`
}

// aggregated selection of "sim_card_flow"
type SimCardFlowAggregate struct {
	Aggregate *SimCardFlowAggregateFields `json:"aggregate"`
	Nodes     []*model.SimCardFlow        `json:"nodes"`
}

// aggregate fields of "sim_card_flow"
type SimCardFlowAggregateFields struct {
	Avg        *SimCardFlowAvgFields        `json:"avg"`
	Count      *int                         `json:"count"`
	Max        *SimCardFlowMaxFields        `json:"max"`
	Min        *SimCardFlowMinFields        `json:"min"`
	Stddev     *SimCardFlowStddevFields     `json:"stddev"`
	StddevPop  *SimCardFlowStddevPopFields  `json:"stddev_pop"`
	StddevSamp *SimCardFlowStddevSampFields `json:"stddev_samp"`
	Sum        *SimCardFlowSumFields        `json:"sum"`
	VarPop     *SimCardFlowVarPopFields     `json:"var_pop"`
	VarSamp    *SimCardFlowVarSampFields    `json:"var_samp"`
	Variance   *SimCardFlowVarianceFields   `json:"variance"`
}

// order by aggregate values of table "sim_card_flow"
type SimCardFlowAggregateOrderBy struct {
	Avg        *SimCardFlowAvgOrderBy        `json:"avg"`
	Count      *model1.OrderBy               `json:"count"`
	Max        *SimCardFlowMaxOrderBy        `json:"max"`
	Min        *SimCardFlowMinOrderBy        `json:"min"`
	Stddev     *SimCardFlowStddevOrderBy     `json:"stddev"`
	StddevPop  *SimCardFlowStddevPopOrderBy  `json:"stddev_pop"`
	StddevSamp *SimCardFlowStddevSampOrderBy `json:"stddev_samp"`
	Sum        *SimCardFlowSumOrderBy        `json:"sum"`
	VarPop     *SimCardFlowVarPopOrderBy     `json:"var_pop"`
	VarSamp    *SimCardFlowVarSampOrderBy    `json:"var_samp"`
	Variance   *SimCardFlowVarianceOrderBy   `json:"variance"`
}

// input type for inserting array relation for remote table "sim_card_flow"
type SimCardFlowArrRelInsertInput struct {
	Data       []*SimCardFlowInsertInput `json:"data"`
	OnConflict *SimCardFlowOnConflict    `json:"on_conflict"`
}

// aggregate avg on columns
type SimCardFlowAvgFields struct {
	CardAvgFlow    *float64 `json:"card_avg_flow"`
	ID             *float64 `json:"id"`
	PoolAvgFlow    *float64 `json:"pool_avg_flow"`
	SuitFlow       *float64 `json:"suit_flow"`
	SuitLeftFlow   *float64 `json:"suit_left_flow"`
	SuitOverFlow   *float64 `json:"suit_over_flow"`
	SuitSmsLeftNum *float64 `json:"suit_sms_left_num"`
	SuitSmsNum     *float64 `json:"suit_sms_num"`
	SuitSmsOverNum *float64 `json:"suit_sms_over_num"`
	SuitUseSmsNum  *float64 `json:"suit_use_sms_num"`
	UseFlow        *float64 `json:"use_flow"`
}

// order by avg() on columns of table "sim_card_flow"
type SimCardFlowAvgOrderBy struct {
	CardAvgFlow    *model1.OrderBy `json:"card_avg_flow"`
	ID             *model1.OrderBy `json:"id"`
	PoolAvgFlow    *model1.OrderBy `json:"pool_avg_flow"`
	SuitFlow       *model1.OrderBy `json:"suit_flow"`
	SuitLeftFlow   *model1.OrderBy `json:"suit_left_flow"`
	SuitOverFlow   *model1.OrderBy `json:"suit_over_flow"`
	SuitSmsLeftNum *model1.OrderBy `json:"suit_sms_left_num"`
	SuitSmsNum     *model1.OrderBy `json:"suit_sms_num"`
	SuitSmsOverNum *model1.OrderBy `json:"suit_sms_over_num"`
	SuitUseSmsNum  *model1.OrderBy `json:"suit_use_sms_num"`
	UseFlow        *model1.OrderBy `json:"use_flow"`
}

// Boolean expression to filter rows from the table "sim_card_flow". All fields are combined with a logical 'AND'.
type SimCardFlowBoolExp struct {
	And            []*SimCardFlowBoolExp            `json:"_and"`
	Not            *SimCardFlowBoolExp              `json:"_not"`
	Or             []*SimCardFlowBoolExp            `json:"_or"`
	CardAvgFlow    *model1.NumericComparisonExp     `json:"card_avg_flow"`
	CardNoRemark   *model1.StringComparisonExp      `json:"card_no_remark"`
	CreateAt       *model1.TimestamptzComparisonExp `json:"create_at"`
	CreateBy       *model1.StringComparisonExp      `json:"create_by"`
	DeleteAt       *model1.TimestamptzComparisonExp `json:"delete_at"`
	DeleteBy       *model1.StringComparisonExp      `json:"delete_by"`
	EnterpriseID   *model1.StringComparisonExp      `json:"enterprise_id"`
	Iccid          *model1.StringComparisonExp      `json:"iccid"`
	ID             *model1.BigintComparisonExp      `json:"id"`
	IotCardNo      *model1.StringComparisonExp      `json:"iot_card_no"`
	IsDelete       *model1.BooleanComparisonExp     `json:"is_delete"`
	IsSharePool    *model1.BooleanComparisonExp     `json:"is_share_pool"`
	PoolAvgFlow    *model1.NumericComparisonExp     `json:"pool_avg_flow"`
	SimCardFlowID  *model1.StringComparisonExp      `json:"sim_card_flow_id"`
	SuitFlow       *model1.NumericComparisonExp     `json:"suit_flow"`
	SuitLeftFlow   *model1.NumericComparisonExp     `json:"suit_left_flow"`
	SuitOverFlow   *model1.NumericComparisonExp     `json:"suit_over_flow"`
	SuitSmsLeftNum *model1.IntComparisonExp         `json:"suit_sms_left_num"`
	SuitSmsNum     *model1.IntComparisonExp         `json:"suit_sms_num"`
	SuitSmsOverNum *model1.IntComparisonExp         `json:"suit_sms_over_num"`
	SuitUseSmsNum  *model1.IntComparisonExp         `json:"suit_use_sms_num"`
	UpdateAt       *model1.TimestamptzComparisonExp `json:"update_at"`
	UpdateBy       *model1.StringComparisonExp      `json:"update_by"`
	UseFlow        *model1.NumericComparisonExp     `json:"use_flow"`
}

// input type for incrementing integer column in table "sim_card_flow"
type SimCardFlowIncInput struct {
	CardAvgFlow    *float64 `json:"card_avg_flow"`
	ID             *int64   `json:"id"`
	PoolAvgFlow    *float64 `json:"pool_avg_flow"`
	SuitFlow       *float64 `json:"suit_flow"`
	SuitLeftFlow   *float64 `json:"suit_left_flow"`
	SuitOverFlow   *float64 `json:"suit_over_flow"`
	SuitSmsLeftNum *int     `json:"suit_sms_left_num"`
	SuitSmsNum     *int     `json:"suit_sms_num"`
	SuitSmsOverNum *int     `json:"suit_sms_over_num"`
	SuitUseSmsNum  *int     `json:"suit_use_sms_num"`
	UseFlow        *float64 `json:"use_flow"`
}

// input type for inserting data into table "sim_card_flow"
type SimCardFlowInsertInput struct {
	CardAvgFlow    *float64   `json:"card_avg_flow"`
	CardNoRemark   *string    `json:"card_no_remark"`
	CreateAt       *time.Time `json:"create_at"`
	CreateBy       *string    `json:"create_by"`
	DeleteAt       *time.Time `json:"delete_at"`
	DeleteBy       *string    `json:"delete_by"`
	EnterpriseID   *string    `json:"enterprise_id"`
	Iccid          *string    `json:"iccid"`
	ID             *int64     `json:"id"`
	IotCardNo      *string    `json:"iot_card_no"`
	IsDelete       *bool      `json:"is_delete"`
	IsSharePool    *bool      `json:"is_share_pool"`
	PoolAvgFlow    *float64   `json:"pool_avg_flow"`
	SimCardFlowID  *string    `json:"sim_card_flow_id"`
	SuitFlow       *float64   `json:"suit_flow"`
	SuitLeftFlow   *float64   `json:"suit_left_flow"`
	SuitOverFlow   *float64   `json:"suit_over_flow"`
	SuitSmsLeftNum *int       `json:"suit_sms_left_num"`
	SuitSmsNum     *int       `json:"suit_sms_num"`
	SuitSmsOverNum *int       `json:"suit_sms_over_num"`
	SuitUseSmsNum  *int       `json:"suit_use_sms_num"`
	UpdateAt       *time.Time `json:"update_at"`
	UpdateBy       *string    `json:"update_by"`
	UseFlow        *float64   `json:"use_flow"`
}

// aggregate max on columns
type SimCardFlowMaxFields struct {
	CardAvgFlow    *float64   `json:"card_avg_flow"`
	CardNoRemark   *string    `json:"card_no_remark"`
	CreateAt       *time.Time `json:"create_at"`
	CreateBy       *string    `json:"create_by"`
	DeleteAt       *time.Time `json:"delete_at"`
	DeleteBy       *string    `json:"delete_by"`
	EnterpriseID   *string    `json:"enterprise_id"`
	Iccid          *string    `json:"iccid"`
	ID             *int64     `json:"id"`
	IotCardNo      *string    `json:"iot_card_no"`
	PoolAvgFlow    *float64   `json:"pool_avg_flow"`
	SimCardFlowID  *string    `json:"sim_card_flow_id"`
	SuitFlow       *float64   `json:"suit_flow"`
	SuitLeftFlow   *float64   `json:"suit_left_flow"`
	SuitOverFlow   *float64   `json:"suit_over_flow"`
	SuitSmsLeftNum *int       `json:"suit_sms_left_num"`
	SuitSmsNum     *int       `json:"suit_sms_num"`
	SuitSmsOverNum *int       `json:"suit_sms_over_num"`
	SuitUseSmsNum  *int       `json:"suit_use_sms_num"`
	UpdateAt       *time.Time `json:"update_at"`
	UpdateBy       *string    `json:"update_by"`
	UseFlow        *float64   `json:"use_flow"`
}

// order by max() on columns of table "sim_card_flow"
type SimCardFlowMaxOrderBy struct {
	CardAvgFlow    *model1.OrderBy `json:"card_avg_flow"`
	CardNoRemark   *model1.OrderBy `json:"card_no_remark"`
	CreateAt       *model1.OrderBy `json:"create_at"`
	CreateBy       *model1.OrderBy `json:"create_by"`
	DeleteAt       *model1.OrderBy `json:"delete_at"`
	DeleteBy       *model1.OrderBy `json:"delete_by"`
	EnterpriseID   *model1.OrderBy `json:"enterprise_id"`
	Iccid          *model1.OrderBy `json:"iccid"`
	ID             *model1.OrderBy `json:"id"`
	IotCardNo      *model1.OrderBy `json:"iot_card_no"`
	PoolAvgFlow    *model1.OrderBy `json:"pool_avg_flow"`
	SimCardFlowID  *model1.OrderBy `json:"sim_card_flow_id"`
	SuitFlow       *model1.OrderBy `json:"suit_flow"`
	SuitLeftFlow   *model1.OrderBy `json:"suit_left_flow"`
	SuitOverFlow   *model1.OrderBy `json:"suit_over_flow"`
	SuitSmsLeftNum *model1.OrderBy `json:"suit_sms_left_num"`
	SuitSmsNum     *model1.OrderBy `json:"suit_sms_num"`
	SuitSmsOverNum *model1.OrderBy `json:"suit_sms_over_num"`
	SuitUseSmsNum  *model1.OrderBy `json:"suit_use_sms_num"`
	UpdateAt       *model1.OrderBy `json:"update_at"`
	UpdateBy       *model1.OrderBy `json:"update_by"`
	UseFlow        *model1.OrderBy `json:"use_flow"`
}

// aggregate min on columns
type SimCardFlowMinFields struct {
	CardAvgFlow    *float64   `json:"card_avg_flow"`
	CardNoRemark   *string    `json:"card_no_remark"`
	CreateAt       *time.Time `json:"create_at"`
	CreateBy       *string    `json:"create_by"`
	DeleteAt       *time.Time `json:"delete_at"`
	DeleteBy       *string    `json:"delete_by"`
	EnterpriseID   *string    `json:"enterprise_id"`
	Iccid          *string    `json:"iccid"`
	ID             *int64     `json:"id"`
	IotCardNo      *string    `json:"iot_card_no"`
	PoolAvgFlow    *float64   `json:"pool_avg_flow"`
	SimCardFlowID  *string    `json:"sim_card_flow_id"`
	SuitFlow       *float64   `json:"suit_flow"`
	SuitLeftFlow   *float64   `json:"suit_left_flow"`
	SuitOverFlow   *float64   `json:"suit_over_flow"`
	SuitSmsLeftNum *int       `json:"suit_sms_left_num"`
	SuitSmsNum     *int       `json:"suit_sms_num"`
	SuitSmsOverNum *int       `json:"suit_sms_over_num"`
	SuitUseSmsNum  *int       `json:"suit_use_sms_num"`
	UpdateAt       *time.Time `json:"update_at"`
	UpdateBy       *string    `json:"update_by"`
	UseFlow        *float64   `json:"use_flow"`
}

// order by min() on columns of table "sim_card_flow"
type SimCardFlowMinOrderBy struct {
	CardAvgFlow    *model1.OrderBy `json:"card_avg_flow"`
	CardNoRemark   *model1.OrderBy `json:"card_no_remark"`
	CreateAt       *model1.OrderBy `json:"create_at"`
	CreateBy       *model1.OrderBy `json:"create_by"`
	DeleteAt       *model1.OrderBy `json:"delete_at"`
	DeleteBy       *model1.OrderBy `json:"delete_by"`
	EnterpriseID   *model1.OrderBy `json:"enterprise_id"`
	Iccid          *model1.OrderBy `json:"iccid"`
	ID             *model1.OrderBy `json:"id"`
	IotCardNo      *model1.OrderBy `json:"iot_card_no"`
	PoolAvgFlow    *model1.OrderBy `json:"pool_avg_flow"`
	SimCardFlowID  *model1.OrderBy `json:"sim_card_flow_id"`
	SuitFlow       *model1.OrderBy `json:"suit_flow"`
	SuitLeftFlow   *model1.OrderBy `json:"suit_left_flow"`
	SuitOverFlow   *model1.OrderBy `json:"suit_over_flow"`
	SuitSmsLeftNum *model1.OrderBy `json:"suit_sms_left_num"`
	SuitSmsNum     *model1.OrderBy `json:"suit_sms_num"`
	SuitSmsOverNum *model1.OrderBy `json:"suit_sms_over_num"`
	SuitUseSmsNum  *model1.OrderBy `json:"suit_use_sms_num"`
	UpdateAt       *model1.OrderBy `json:"update_at"`
	UpdateBy       *model1.OrderBy `json:"update_by"`
	UseFlow        *model1.OrderBy `json:"use_flow"`
}

// response of any mutation on the table "sim_card_flow"
type SimCardFlowMutationResponse struct {
	// number of affected rows by the mutation
	AffectedRows int `json:"affected_rows"`
	// data of the affected rows by the mutation
	Returning []*model.SimCardFlow `json:"returning"`
}

// input type for inserting object relation for remote table "sim_card_flow"
type SimCardFlowObjRelInsertInput struct {
	Data       *SimCardFlowInsertInput `json:"data"`
	OnConflict *SimCardFlowOnConflict  `json:"on_conflict"`
}

// on conflict condition type for table "sim_card_flow"
type SimCardFlowOnConflict struct {
	Constraint    SimCardFlowConstraint     `json:"constraint"`
	UpdateColumns []SimCardFlowUpdateColumn `json:"update_columns"`
	Where         *SimCardFlowBoolExp       `json:"where"`
}

// ordering options when selecting data from "sim_card_flow"
type SimCardFlowOrderBy struct {
	CardAvgFlow    *model1.OrderBy `json:"card_avg_flow"`
	CardNoRemark   *model1.OrderBy `json:"card_no_remark"`
	CreateAt       *model1.OrderBy `json:"create_at"`
	CreateBy       *model1.OrderBy `json:"create_by"`
	DeleteAt       *model1.OrderBy `json:"delete_at"`
	DeleteBy       *model1.OrderBy `json:"delete_by"`
	EnterpriseID   *model1.OrderBy `json:"enterprise_id"`
	Iccid          *model1.OrderBy `json:"iccid"`
	ID             *model1.OrderBy `json:"id"`
	IotCardNo      *model1.OrderBy `json:"iot_card_no"`
	IsDelete       *model1.OrderBy `json:"is_delete"`
	IsSharePool    *model1.OrderBy `json:"is_share_pool"`
	PoolAvgFlow    *model1.OrderBy `json:"pool_avg_flow"`
	SimCardFlowID  *model1.OrderBy `json:"sim_card_flow_id"`
	SuitFlow       *model1.OrderBy `json:"suit_flow"`
	SuitLeftFlow   *model1.OrderBy `json:"suit_left_flow"`
	SuitOverFlow   *model1.OrderBy `json:"suit_over_flow"`
	SuitSmsLeftNum *model1.OrderBy `json:"suit_sms_left_num"`
	SuitSmsNum     *model1.OrderBy `json:"suit_sms_num"`
	SuitSmsOverNum *model1.OrderBy `json:"suit_sms_over_num"`
	SuitUseSmsNum  *model1.OrderBy `json:"suit_use_sms_num"`
	UpdateAt       *model1.OrderBy `json:"update_at"`
	UpdateBy       *model1.OrderBy `json:"update_by"`
	UseFlow        *model1.OrderBy `json:"use_flow"`
}

// primary key columns input for table: "sim_card_flow"
type SimCardFlowPkColumnsInput struct {
	// ID
	ID int64 `json:"id"`
}

// input type for updating data in table "sim_card_flow"
type SimCardFlowSetInput struct {
	CardAvgFlow    *float64   `json:"card_avg_flow"`
	CardNoRemark   *string    `json:"card_no_remark"`
	CreateAt       *time.Time `json:"create_at"`
	CreateBy       *string    `json:"create_by"`
	DeleteAt       *time.Time `json:"delete_at"`
	DeleteBy       *string    `json:"delete_by"`
	EnterpriseID   *string    `json:"enterprise_id"`
	Iccid          *string    `json:"iccid"`
	ID             *int64     `json:"id"`
	IotCardNo      *string    `json:"iot_card_no"`
	IsDelete       *bool      `json:"is_delete"`
	IsSharePool    *bool      `json:"is_share_pool"`
	PoolAvgFlow    *float64   `json:"pool_avg_flow"`
	SimCardFlowID  *string    `json:"sim_card_flow_id"`
	SuitFlow       *float64   `json:"suit_flow"`
	SuitLeftFlow   *float64   `json:"suit_left_flow"`
	SuitOverFlow   *float64   `json:"suit_over_flow"`
	SuitSmsLeftNum *int       `json:"suit_sms_left_num"`
	SuitSmsNum     *int       `json:"suit_sms_num"`
	SuitSmsOverNum *int       `json:"suit_sms_over_num"`
	SuitUseSmsNum  *int       `json:"suit_use_sms_num"`
	UpdateAt       *time.Time `json:"update_at"`
	UpdateBy       *string    `json:"update_by"`
	UseFlow        *float64   `json:"use_flow"`
}

// aggregate stddev on columns
type SimCardFlowStddevFields struct {
	CardAvgFlow    *float64 `json:"card_avg_flow"`
	ID             *float64 `json:"id"`
	PoolAvgFlow    *float64 `json:"pool_avg_flow"`
	SuitFlow       *float64 `json:"suit_flow"`
	SuitLeftFlow   *float64 `json:"suit_left_flow"`
	SuitOverFlow   *float64 `json:"suit_over_flow"`
	SuitSmsLeftNum *float64 `json:"suit_sms_left_num"`
	SuitSmsNum     *float64 `json:"suit_sms_num"`
	SuitSmsOverNum *float64 `json:"suit_sms_over_num"`
	SuitUseSmsNum  *float64 `json:"suit_use_sms_num"`
	UseFlow        *float64 `json:"use_flow"`
}

// order by stddev() on columns of table "sim_card_flow"
type SimCardFlowStddevOrderBy struct {
	CardAvgFlow    *model1.OrderBy `json:"card_avg_flow"`
	ID             *model1.OrderBy `json:"id"`
	PoolAvgFlow    *model1.OrderBy `json:"pool_avg_flow"`
	SuitFlow       *model1.OrderBy `json:"suit_flow"`
	SuitLeftFlow   *model1.OrderBy `json:"suit_left_flow"`
	SuitOverFlow   *model1.OrderBy `json:"suit_over_flow"`
	SuitSmsLeftNum *model1.OrderBy `json:"suit_sms_left_num"`
	SuitSmsNum     *model1.OrderBy `json:"suit_sms_num"`
	SuitSmsOverNum *model1.OrderBy `json:"suit_sms_over_num"`
	SuitUseSmsNum  *model1.OrderBy `json:"suit_use_sms_num"`
	UseFlow        *model1.OrderBy `json:"use_flow"`
}

// aggregate stddev_pop on columns
type SimCardFlowStddevPopFields struct {
	CardAvgFlow    *float64 `json:"card_avg_flow"`
	ID             *float64 `json:"id"`
	PoolAvgFlow    *float64 `json:"pool_avg_flow"`
	SuitFlow       *float64 `json:"suit_flow"`
	SuitLeftFlow   *float64 `json:"suit_left_flow"`
	SuitOverFlow   *float64 `json:"suit_over_flow"`
	SuitSmsLeftNum *float64 `json:"suit_sms_left_num"`
	SuitSmsNum     *float64 `json:"suit_sms_num"`
	SuitSmsOverNum *float64 `json:"suit_sms_over_num"`
	SuitUseSmsNum  *float64 `json:"suit_use_sms_num"`
	UseFlow        *float64 `json:"use_flow"`
}

// order by stddev_pop() on columns of table "sim_card_flow"
type SimCardFlowStddevPopOrderBy struct {
	CardAvgFlow    *model1.OrderBy `json:"card_avg_flow"`
	ID             *model1.OrderBy `json:"id"`
	PoolAvgFlow    *model1.OrderBy `json:"pool_avg_flow"`
	SuitFlow       *model1.OrderBy `json:"suit_flow"`
	SuitLeftFlow   *model1.OrderBy `json:"suit_left_flow"`
	SuitOverFlow   *model1.OrderBy `json:"suit_over_flow"`
	SuitSmsLeftNum *model1.OrderBy `json:"suit_sms_left_num"`
	SuitSmsNum     *model1.OrderBy `json:"suit_sms_num"`
	SuitSmsOverNum *model1.OrderBy `json:"suit_sms_over_num"`
	SuitUseSmsNum  *model1.OrderBy `json:"suit_use_sms_num"`
	UseFlow        *model1.OrderBy `json:"use_flow"`
}

// aggregate stddev_samp on columns
type SimCardFlowStddevSampFields struct {
	CardAvgFlow    *float64 `json:"card_avg_flow"`
	ID             *float64 `json:"id"`
	PoolAvgFlow    *float64 `json:"pool_avg_flow"`
	SuitFlow       *float64 `json:"suit_flow"`
	SuitLeftFlow   *float64 `json:"suit_left_flow"`
	SuitOverFlow   *float64 `json:"suit_over_flow"`
	SuitSmsLeftNum *float64 `json:"suit_sms_left_num"`
	SuitSmsNum     *float64 `json:"suit_sms_num"`
	SuitSmsOverNum *float64 `json:"suit_sms_over_num"`
	SuitUseSmsNum  *float64 `json:"suit_use_sms_num"`
	UseFlow        *float64 `json:"use_flow"`
}

// order by stddev_samp() on columns of table "sim_card_flow"
type SimCardFlowStddevSampOrderBy struct {
	CardAvgFlow    *model1.OrderBy `json:"card_avg_flow"`
	ID             *model1.OrderBy `json:"id"`
	PoolAvgFlow    *model1.OrderBy `json:"pool_avg_flow"`
	SuitFlow       *model1.OrderBy `json:"suit_flow"`
	SuitLeftFlow   *model1.OrderBy `json:"suit_left_flow"`
	SuitOverFlow   *model1.OrderBy `json:"suit_over_flow"`
	SuitSmsLeftNum *model1.OrderBy `json:"suit_sms_left_num"`
	SuitSmsNum     *model1.OrderBy `json:"suit_sms_num"`
	SuitSmsOverNum *model1.OrderBy `json:"suit_sms_over_num"`
	SuitUseSmsNum  *model1.OrderBy `json:"suit_use_sms_num"`
	UseFlow        *model1.OrderBy `json:"use_flow"`
}

// aggregate sum on columns
type SimCardFlowSumFields struct {
	CardAvgFlow    *float64 `json:"card_avg_flow"`
	ID             *int64   `json:"id"`
	PoolAvgFlow    *float64 `json:"pool_avg_flow"`
	SuitFlow       *float64 `json:"suit_flow"`
	SuitLeftFlow   *float64 `json:"suit_left_flow"`
	SuitOverFlow   *float64 `json:"suit_over_flow"`
	SuitSmsLeftNum *int     `json:"suit_sms_left_num"`
	SuitSmsNum     *int     `json:"suit_sms_num"`
	SuitSmsOverNum *int     `json:"suit_sms_over_num"`
	SuitUseSmsNum  *int     `json:"suit_use_sms_num"`
	UseFlow        *float64 `json:"use_flow"`
}

// order by sum() on columns of table "sim_card_flow"
type SimCardFlowSumOrderBy struct {
	CardAvgFlow    *model1.OrderBy `json:"card_avg_flow"`
	ID             *model1.OrderBy `json:"id"`
	PoolAvgFlow    *model1.OrderBy `json:"pool_avg_flow"`
	SuitFlow       *model1.OrderBy `json:"suit_flow"`
	SuitLeftFlow   *model1.OrderBy `json:"suit_left_flow"`
	SuitOverFlow   *model1.OrderBy `json:"suit_over_flow"`
	SuitSmsLeftNum *model1.OrderBy `json:"suit_sms_left_num"`
	SuitSmsNum     *model1.OrderBy `json:"suit_sms_num"`
	SuitSmsOverNum *model1.OrderBy `json:"suit_sms_over_num"`
	SuitUseSmsNum  *model1.OrderBy `json:"suit_use_sms_num"`
	UseFlow        *model1.OrderBy `json:"use_flow"`
}

// aggregate var_pop on columns
type SimCardFlowVarPopFields struct {
	CardAvgFlow    *float64 `json:"card_avg_flow"`
	ID             *float64 `json:"id"`
	PoolAvgFlow    *float64 `json:"pool_avg_flow"`
	SuitFlow       *float64 `json:"suit_flow"`
	SuitLeftFlow   *float64 `json:"suit_left_flow"`
	SuitOverFlow   *float64 `json:"suit_over_flow"`
	SuitSmsLeftNum *float64 `json:"suit_sms_left_num"`
	SuitSmsNum     *float64 `json:"suit_sms_num"`
	SuitSmsOverNum *float64 `json:"suit_sms_over_num"`
	SuitUseSmsNum  *float64 `json:"suit_use_sms_num"`
	UseFlow        *float64 `json:"use_flow"`
}

// order by var_pop() on columns of table "sim_card_flow"
type SimCardFlowVarPopOrderBy struct {
	CardAvgFlow    *model1.OrderBy `json:"card_avg_flow"`
	ID             *model1.OrderBy `json:"id"`
	PoolAvgFlow    *model1.OrderBy `json:"pool_avg_flow"`
	SuitFlow       *model1.OrderBy `json:"suit_flow"`
	SuitLeftFlow   *model1.OrderBy `json:"suit_left_flow"`
	SuitOverFlow   *model1.OrderBy `json:"suit_over_flow"`
	SuitSmsLeftNum *model1.OrderBy `json:"suit_sms_left_num"`
	SuitSmsNum     *model1.OrderBy `json:"suit_sms_num"`
	SuitSmsOverNum *model1.OrderBy `json:"suit_sms_over_num"`
	SuitUseSmsNum  *model1.OrderBy `json:"suit_use_sms_num"`
	UseFlow        *model1.OrderBy `json:"use_flow"`
}

// aggregate var_samp on columns
type SimCardFlowVarSampFields struct {
	CardAvgFlow    *float64 `json:"card_avg_flow"`
	ID             *float64 `json:"id"`
	PoolAvgFlow    *float64 `json:"pool_avg_flow"`
	SuitFlow       *float64 `json:"suit_flow"`
	SuitLeftFlow   *float64 `json:"suit_left_flow"`
	SuitOverFlow   *float64 `json:"suit_over_flow"`
	SuitSmsLeftNum *float64 `json:"suit_sms_left_num"`
	SuitSmsNum     *float64 `json:"suit_sms_num"`
	SuitSmsOverNum *float64 `json:"suit_sms_over_num"`
	SuitUseSmsNum  *float64 `json:"suit_use_sms_num"`
	UseFlow        *float64 `json:"use_flow"`
}

// order by var_samp() on columns of table "sim_card_flow"
type SimCardFlowVarSampOrderBy struct {
	CardAvgFlow    *model1.OrderBy `json:"card_avg_flow"`
	ID             *model1.OrderBy `json:"id"`
	PoolAvgFlow    *model1.OrderBy `json:"pool_avg_flow"`
	SuitFlow       *model1.OrderBy `json:"suit_flow"`
	SuitLeftFlow   *model1.OrderBy `json:"suit_left_flow"`
	SuitOverFlow   *model1.OrderBy `json:"suit_over_flow"`
	SuitSmsLeftNum *model1.OrderBy `json:"suit_sms_left_num"`
	SuitSmsNum     *model1.OrderBy `json:"suit_sms_num"`
	SuitSmsOverNum *model1.OrderBy `json:"suit_sms_over_num"`
	SuitUseSmsNum  *model1.OrderBy `json:"suit_use_sms_num"`
	UseFlow        *model1.OrderBy `json:"use_flow"`
}

// aggregate variance on columns
type SimCardFlowVarianceFields struct {
	CardAvgFlow    *float64 `json:"card_avg_flow"`
	ID             *float64 `json:"id"`
	PoolAvgFlow    *float64 `json:"pool_avg_flow"`
	SuitFlow       *float64 `json:"suit_flow"`
	SuitLeftFlow   *float64 `json:"suit_left_flow"`
	SuitOverFlow   *float64 `json:"suit_over_flow"`
	SuitSmsLeftNum *float64 `json:"suit_sms_left_num"`
	SuitSmsNum     *float64 `json:"suit_sms_num"`
	SuitSmsOverNum *float64 `json:"suit_sms_over_num"`
	SuitUseSmsNum  *float64 `json:"suit_use_sms_num"`
	UseFlow        *float64 `json:"use_flow"`
}

// order by variance() on columns of table "sim_card_flow"
type SimCardFlowVarianceOrderBy struct {
	CardAvgFlow    *model1.OrderBy `json:"card_avg_flow"`
	ID             *model1.OrderBy `json:"id"`
	PoolAvgFlow    *model1.OrderBy `json:"pool_avg_flow"`
	SuitFlow       *model1.OrderBy `json:"suit_flow"`
	SuitLeftFlow   *model1.OrderBy `json:"suit_left_flow"`
	SuitOverFlow   *model1.OrderBy `json:"suit_over_flow"`
	SuitSmsLeftNum *model1.OrderBy `json:"suit_sms_left_num"`
	SuitSmsNum     *model1.OrderBy `json:"suit_sms_num"`
	SuitSmsOverNum *model1.OrderBy `json:"suit_sms_over_num"`
	SuitUseSmsNum  *model1.OrderBy `json:"suit_use_sms_num"`
	UseFlow        *model1.OrderBy `json:"use_flow"`
}

// input type for incrementing integer column in table "sim_card"
type SimCardIncInput struct {
	ID         *int64 `json:"id"`
	MobileType *int   `json:"mobile_type"`
}

// input type for inserting data into table "sim_card"
type SimCardInsertInput struct {
	CreateAt    *time.Time `json:"create_at"`
	CreateBy    *string    `json:"create_by"`
	DeleteAt    *time.Time `json:"delete_at"`
	DeleteBy    *string    `json:"delete_by"`
	DeptID      *string    `json:"dept_id"`
	ID          *int64     `json:"id"`
	IsDelete    *bool      `json:"is_delete"`
	MobileType  *int       `json:"mobile_type"`
	OperatorsID *string    `json:"operators_id"`
	ProxyrgID   *string    `json:"proxyrg_id"`
	Remark      *string    `json:"remark"`
	SimCardID   *string    `json:"sim_card_id"`
	SimNumber   *string    `json:"sim_number"`
	TerminalID  *string    `json:"terminal_id"`
	UpdateAt    *time.Time `json:"update_at"`
	UpdateBy    *string    `json:"update_by"`
}

// aggregate max on columns
type SimCardMaxFields struct {
	CreateAt    *time.Time `json:"create_at"`
	CreateBy    *string    `json:"create_by"`
	DeleteAt    *time.Time `json:"delete_at"`
	DeleteBy    *string    `json:"delete_by"`
	DeptID      *string    `json:"dept_id"`
	ID          *int64     `json:"id"`
	MobileType  *int       `json:"mobile_type"`
	OperatorsID *string    `json:"operators_id"`
	ProxyrgID   *string    `json:"proxyrg_id"`
	Remark      *string    `json:"remark"`
	SimCardID   *string    `json:"sim_card_id"`
	SimNumber   *string    `json:"sim_number"`
	TerminalID  *string    `json:"terminal_id"`
	UpdateAt    *time.Time `json:"update_at"`
	UpdateBy    *string    `json:"update_by"`
}

// order by max() on columns of table "sim_card"
type SimCardMaxOrderBy struct {
	CreateAt    *model1.OrderBy `json:"create_at"`
	CreateBy    *model1.OrderBy `json:"create_by"`
	DeleteAt    *model1.OrderBy `json:"delete_at"`
	DeleteBy    *model1.OrderBy `json:"delete_by"`
	DeptID      *model1.OrderBy `json:"dept_id"`
	ID          *model1.OrderBy `json:"id"`
	MobileType  *model1.OrderBy `json:"mobile_type"`
	OperatorsID *model1.OrderBy `json:"operators_id"`
	ProxyrgID   *model1.OrderBy `json:"proxyrg_id"`
	Remark      *model1.OrderBy `json:"remark"`
	SimCardID   *model1.OrderBy `json:"sim_card_id"`
	SimNumber   *model1.OrderBy `json:"sim_number"`
	TerminalID  *model1.OrderBy `json:"terminal_id"`
	UpdateAt    *model1.OrderBy `json:"update_at"`
	UpdateBy    *model1.OrderBy `json:"update_by"`
}

// aggregate min on columns
type SimCardMinFields struct {
	CreateAt    *time.Time `json:"create_at"`
	CreateBy    *string    `json:"create_by"`
	DeleteAt    *time.Time `json:"delete_at"`
	DeleteBy    *string    `json:"delete_by"`
	DeptID      *string    `json:"dept_id"`
	ID          *int64     `json:"id"`
	MobileType  *int       `json:"mobile_type"`
	OperatorsID *string    `json:"operators_id"`
	ProxyrgID   *string    `json:"proxyrg_id"`
	Remark      *string    `json:"remark"`
	SimCardID   *string    `json:"sim_card_id"`
	SimNumber   *string    `json:"sim_number"`
	TerminalID  *string    `json:"terminal_id"`
	UpdateAt    *time.Time `json:"update_at"`
	UpdateBy    *string    `json:"update_by"`
}

// order by min() on columns of table "sim_card"
type SimCardMinOrderBy struct {
	CreateAt    *model1.OrderBy `json:"create_at"`
	CreateBy    *model1.OrderBy `json:"create_by"`
	DeleteAt    *model1.OrderBy `json:"delete_at"`
	DeleteBy    *model1.OrderBy `json:"delete_by"`
	DeptID      *model1.OrderBy `json:"dept_id"`
	ID          *model1.OrderBy `json:"id"`
	MobileType  *model1.OrderBy `json:"mobile_type"`
	OperatorsID *model1.OrderBy `json:"operators_id"`
	ProxyrgID   *model1.OrderBy `json:"proxyrg_id"`
	Remark      *model1.OrderBy `json:"remark"`
	SimCardID   *model1.OrderBy `json:"sim_card_id"`
	SimNumber   *model1.OrderBy `json:"sim_number"`
	TerminalID  *model1.OrderBy `json:"terminal_id"`
	UpdateAt    *model1.OrderBy `json:"update_at"`
	UpdateBy    *model1.OrderBy `json:"update_by"`
}

// response of any mutation on the table "sim_card"
type SimCardMutationResponse struct {
	// number of affected rows by the mutation
	AffectedRows int `json:"affected_rows"`
	// data of the affected rows by the mutation
	Returning []*model.SimCard `json:"returning"`
}

// input type for inserting object relation for remote table "sim_card"
type SimCardObjRelInsertInput struct {
	Data       *SimCardInsertInput `json:"data"`
	OnConflict *SimCardOnConflict  `json:"on_conflict"`
}

// on conflict condition type for table "sim_card"
type SimCardOnConflict struct {
	Constraint    SimCardConstraint     `json:"constraint"`
	UpdateColumns []SimCardUpdateColumn `json:"update_columns"`
	Where         *SimCardBoolExp       `json:"where"`
}

// ordering options when selecting data from "sim_card"
type SimCardOrderBy struct {
	CreateAt    *model1.OrderBy `json:"create_at"`
	CreateBy    *model1.OrderBy `json:"create_by"`
	DeleteAt    *model1.OrderBy `json:"delete_at"`
	DeleteBy    *model1.OrderBy `json:"delete_by"`
	DeptID      *model1.OrderBy `json:"dept_id"`
	ID          *model1.OrderBy `json:"id"`
	IsDelete    *model1.OrderBy `json:"is_delete"`
	MobileType  *model1.OrderBy `json:"mobile_type"`
	OperatorsID *model1.OrderBy `json:"operators_id"`
	ProxyrgID   *model1.OrderBy `json:"proxyrg_id"`
	Remark      *model1.OrderBy `json:"remark"`
	SimCardID   *model1.OrderBy `json:"sim_card_id"`
	SimNumber   *model1.OrderBy `json:"sim_number"`
	TerminalID  *model1.OrderBy `json:"terminal_id"`
	UpdateAt    *model1.OrderBy `json:"update_at"`
	UpdateBy    *model1.OrderBy `json:"update_by"`
}

// primary key columns input for table: "sim_card"
type SimCardPkColumnsInput struct {
	// ID
	ID int64 `json:"id"`
}

// input type for updating data in table "sim_card"
type SimCardSetInput struct {
	CreateAt    *time.Time `json:"create_at"`
	CreateBy    *string    `json:"create_by"`
	DeleteAt    *time.Time `json:"delete_at"`
	DeleteBy    *string    `json:"delete_by"`
	DeptID      *string    `json:"dept_id"`
	ID          *int64     `json:"id"`
	IsDelete    *bool      `json:"is_delete"`
	MobileType  *int       `json:"mobile_type"`
	OperatorsID *string    `json:"operators_id"`
	ProxyrgID   *string    `json:"proxyrg_id"`
	Remark      *string    `json:"remark"`
	SimCardID   *string    `json:"sim_card_id"`
	SimNumber   *string    `json:"sim_number"`
	TerminalID  *string    `json:"terminal_id"`
	UpdateAt    *time.Time `json:"update_at"`
	UpdateBy    *string    `json:"update_by"`
}

// aggregate stddev on columns
type SimCardStddevFields struct {
	ID         *float64 `json:"id"`
	MobileType *float64 `json:"mobile_type"`
}

// order by stddev() on columns of table "sim_card"
type SimCardStddevOrderBy struct {
	ID         *model1.OrderBy `json:"id"`
	MobileType *model1.OrderBy `json:"mobile_type"`
}

// aggregate stddev_pop on columns
type SimCardStddevPopFields struct {
	ID         *float64 `json:"id"`
	MobileType *float64 `json:"mobile_type"`
}

// order by stddev_pop() on columns of table "sim_card"
type SimCardStddevPopOrderBy struct {
	ID         *model1.OrderBy `json:"id"`
	MobileType *model1.OrderBy `json:"mobile_type"`
}

// aggregate stddev_samp on columns
type SimCardStddevSampFields struct {
	ID         *float64 `json:"id"`
	MobileType *float64 `json:"mobile_type"`
}

// order by stddev_samp() on columns of table "sim_card"
type SimCardStddevSampOrderBy struct {
	ID         *model1.OrderBy `json:"id"`
	MobileType *model1.OrderBy `json:"mobile_type"`
}

// aggregate sum on columns
type SimCardSumFields struct {
	ID         *int64 `json:"id"`
	MobileType *int   `json:"mobile_type"`
}

// order by sum() on columns of table "sim_card"
type SimCardSumOrderBy struct {
	ID         *model1.OrderBy `json:"id"`
	MobileType *model1.OrderBy `json:"mobile_type"`
}

// aggregate var_pop on columns
type SimCardVarPopFields struct {
	ID         *float64 `json:"id"`
	MobileType *float64 `json:"mobile_type"`
}

// order by var_pop() on columns of table "sim_card"
type SimCardVarPopOrderBy struct {
	ID         *model1.OrderBy `json:"id"`
	MobileType *model1.OrderBy `json:"mobile_type"`
}

// aggregate var_samp on columns
type SimCardVarSampFields struct {
	ID         *float64 `json:"id"`
	MobileType *float64 `json:"mobile_type"`
}

// order by var_samp() on columns of table "sim_card"
type SimCardVarSampOrderBy struct {
	ID         *model1.OrderBy `json:"id"`
	MobileType *model1.OrderBy `json:"mobile_type"`
}

// aggregate variance on columns
type SimCardVarianceFields struct {
	ID         *float64 `json:"id"`
	MobileType *float64 `json:"mobile_type"`
}

// order by variance() on columns of table "sim_card"
type SimCardVarianceOrderBy struct {
	ID         *model1.OrderBy `json:"id"`
	MobileType *model1.OrderBy `json:"mobile_type"`
}

// aggregated selection of "terminal"
type TerminalAggregate struct {
	Aggregate *TerminalAggregateFields `json:"aggregate"`
	Nodes     []*model.Terminal        `json:"nodes"`
}

// aggregate fields of "terminal"
type TerminalAggregateFields struct {
	Avg        *TerminalAvgFields        `json:"avg"`
	Count      *int                      `json:"count"`
	Max        *TerminalMaxFields        `json:"max"`
	Min        *TerminalMinFields        `json:"min"`
	Stddev     *TerminalStddevFields     `json:"stddev"`
	StddevPop  *TerminalStddevPopFields  `json:"stddev_pop"`
	StddevSamp *TerminalStddevSampFields `json:"stddev_samp"`
	Sum        *TerminalSumFields        `json:"sum"`
	VarPop     *TerminalVarPopFields     `json:"var_pop"`
	VarSamp    *TerminalVarSampFields    `json:"var_samp"`
	Variance   *TerminalVarianceFields   `json:"variance"`
}

// order by aggregate values of table "terminal"
type TerminalAggregateOrderBy struct {
	Avg        *TerminalAvgOrderBy        `json:"avg"`
	Count      *model1.OrderBy            `json:"count"`
	Max        *TerminalMaxOrderBy        `json:"max"`
	Min        *TerminalMinOrderBy        `json:"min"`
	Stddev     *TerminalStddevOrderBy     `json:"stddev"`
	StddevPop  *TerminalStddevPopOrderBy  `json:"stddev_pop"`
	StddevSamp *TerminalStddevSampOrderBy `json:"stddev_samp"`
	Sum        *TerminalSumOrderBy        `json:"sum"`
	VarPop     *TerminalVarPopOrderBy     `json:"var_pop"`
	VarSamp    *TerminalVarSampOrderBy    `json:"var_samp"`
	Variance   *TerminalVarianceOrderBy   `json:"variance"`
}

// input type for inserting array relation for remote table "terminal"
type TerminalArrRelInsertInput struct {
	Data       []*TerminalInsertInput `json:"data"`
	OnConflict *TerminalOnConflict    `json:"on_conflict"`
}

// aggregate avg on columns
type TerminalAvgFields struct {
	CameraNum *float64 `json:"camera_num"`
	ID        *float64 `json:"id"`
}

// order by avg() on columns of table "terminal"
type TerminalAvgOrderBy struct {
	CameraNum *model1.OrderBy `json:"camera_num"`
	ID        *model1.OrderBy `json:"id"`
}

// Boolean expression to filter rows from the table "terminal". All fields are combined with a logical 'AND'.
type TerminalBoolExp struct {
	And              []*TerminalBoolExp               `json:"_and"`
	Not              *TerminalBoolExp                 `json:"_not"`
	Or               []*TerminalBoolExp               `json:"_or"`
	AdasModel        *model1.StringComparisonExp      `json:"adas_model"`
	AuthKey          *model1.StringComparisonExp      `json:"auth_key"`
	CameraNum        *model1.IntComparisonExp         `json:"camera_num"`
	ChannelNo        *model1.StringComparisonExp      `json:"channel_no"`
	CityID           *model1.StringComparisonExp      `json:"city_id"`
	CreateAt         *model1.TimestamptzComparisonExp `json:"create_at"`
	CreateBy         *model1.StringComparisonExp      `json:"create_by"`
	DeleteAt         *model1.TimestamptzComparisonExp `json:"delete_at"`
	DeleteBy         *model1.StringComparisonExp      `json:"delete_by"`
	DeptID           *model1.StringComparisonExp      `json:"dept_id"`
	FirstInstallTime *model1.TimestamptzComparisonExp `json:"first_install_time"`
	GuaranteeDate    *model1.TimestamptzComparisonExp `json:"guarantee_date"`
	ID               *model1.BigintComparisonExp      `json:"id"`
	Imei             *model1.StringComparisonExp      `json:"imei"`
	InstallManID     *model1.StringComparisonExp      `json:"install_man_id"`
	IsDelete         *model1.BooleanComparisonExp     `json:"is_delete"`
	IsReg            *model1.BooleanComparisonExp     `json:"is_reg"`
	IsSupportPhoto   *model1.BooleanComparisonExp     `json:"is_support_photo"`
	MockAuthKey      *model1.StringComparisonExp      `json:"mock_auth_key"`
	ProduceDate      *model1.TimestamptzComparisonExp `json:"produce_date"`
	ProveProxyrgID   *model1.StringComparisonExp      `json:"prove_proxyrg_id"`
	ProvinceID       *model1.StringComparisonExp      `json:"province_id"`
	ProxyrgID        *model1.StringComparisonExp      `json:"proxyrg_id"`
	RecordDate       *model1.TimestamptzComparisonExp `json:"record_date"`
	RegID            *model1.StringComparisonExp      `json:"reg_id"`
	Remarks          *model1.StringComparisonExp      `json:"remarks"`
	RemoveReason     *model1.StringComparisonExp      `json:"remove_reason"`
	SimID            *model1.StringComparisonExp      `json:"sim_id"`
	SprgID           *model1.StringComparisonExp      `json:"sprg_id"`
	TerminalID       *model1.StringComparisonExp      `json:"terminal_id"`
	TypeID           *model1.StringComparisonExp      `json:"type_id"`
	UpdateAt         *model1.TimestamptzComparisonExp `json:"update_at"`
	UpdateBy         *model1.StringComparisonExp      `json:"update_by"`
	VehicleID        *model1.StringComparisonExp      `json:"vehicle_id"`
	VersionNumber    *model1.StringComparisonExp      `json:"version_number"`
}

// aggregated selection of "terminal_factory"
type TerminalFactoryAggregate struct {
	Aggregate *TerminalFactoryAggregateFields `json:"aggregate"`
	Nodes     []*model.TerminalFactory        `json:"nodes"`
}

// aggregate fields of "terminal_factory"
type TerminalFactoryAggregateFields struct {
	Avg        *TerminalFactoryAvgFields        `json:"avg"`
	Count      *int                             `json:"count"`
	Max        *TerminalFactoryMaxFields        `json:"max"`
	Min        *TerminalFactoryMinFields        `json:"min"`
	Stddev     *TerminalFactoryStddevFields     `json:"stddev"`
	StddevPop  *TerminalFactoryStddevPopFields  `json:"stddev_pop"`
	StddevSamp *TerminalFactoryStddevSampFields `json:"stddev_samp"`
	Sum        *TerminalFactorySumFields        `json:"sum"`
	VarPop     *TerminalFactoryVarPopFields     `json:"var_pop"`
	VarSamp    *TerminalFactoryVarSampFields    `json:"var_samp"`
	Variance   *TerminalFactoryVarianceFields   `json:"variance"`
}

// order by aggregate values of table "terminal_factory"
type TerminalFactoryAggregateOrderBy struct {
	Avg        *TerminalFactoryAvgOrderBy        `json:"avg"`
	Count      *model1.OrderBy                   `json:"count"`
	Max        *TerminalFactoryMaxOrderBy        `json:"max"`
	Min        *TerminalFactoryMinOrderBy        `json:"min"`
	Stddev     *TerminalFactoryStddevOrderBy     `json:"stddev"`
	StddevPop  *TerminalFactoryStddevPopOrderBy  `json:"stddev_pop"`
	StddevSamp *TerminalFactoryStddevSampOrderBy `json:"stddev_samp"`
	Sum        *TerminalFactorySumOrderBy        `json:"sum"`
	VarPop     *TerminalFactoryVarPopOrderBy     `json:"var_pop"`
	VarSamp    *TerminalFactoryVarSampOrderBy    `json:"var_samp"`
	Variance   *TerminalFactoryVarianceOrderBy   `json:"variance"`
}

// input type for inserting array relation for remote table "terminal_factory"
type TerminalFactoryArrRelInsertInput struct {
	Data       []*TerminalFactoryInsertInput `json:"data"`
	OnConflict *TerminalFactoryOnConflict    `json:"on_conflict"`
}

// aggregate avg on columns
type TerminalFactoryAvgFields struct {
	ID *float64 `json:"id"`
}

// order by avg() on columns of table "terminal_factory"
type TerminalFactoryAvgOrderBy struct {
	ID *model1.OrderBy `json:"id"`
}

// Boolean expression to filter rows from the table "terminal_factory". All fields are combined with a logical 'AND'.
type TerminalFactoryBoolExp struct {
	And              []*TerminalFactoryBoolExp        `json:"_and"`
	Not              *TerminalFactoryBoolExp          `json:"_not"`
	Or               []*TerminalFactoryBoolExp        `json:"_or"`
	Address          *model1.StringComparisonExp      `json:"address"`
	Contact          *model1.StringComparisonExp      `json:"contact"`
	ContactPhone     *model1.StringComparisonExp      `json:"contact_phone"`
	CreateAt         *model1.TimestamptzComparisonExp `json:"create_at"`
	CreateBy         *model1.StringComparisonExp      `json:"create_by"`
	DeleteAt         *model1.TimestamptzComparisonExp `json:"delete_at"`
	DeleteBy         *model1.StringComparisonExp      `json:"delete_by"`
	FactoryID        *model1.StringComparisonExp      `json:"factory_id"`
	FactoryName      *model1.StringComparisonExp      `json:"factory_name"`
	ID               *model1.BigintComparisonExp      `json:"id"`
	IsDelete         *model1.BooleanComparisonExp     `json:"is_delete"`
	Remark           *model1.StringComparisonExp      `json:"remark"`
	TechContact      *model1.StringComparisonExp      `json:"tech_contact"`
	TechContactPhone *model1.StringComparisonExp      `json:"tech_contact_phone"`
	UpdateAt         *model1.TimestamptzComparisonExp `json:"update_at"`
	UpdateBy         *model1.StringComparisonExp      `json:"update_by"`
}

// input type for incrementing integer column in table "terminal_factory"
type TerminalFactoryIncInput struct {
	ID *int64 `json:"id"`
}

// input type for inserting data into table "terminal_factory"
type TerminalFactoryInsertInput struct {
	Address          *string    `json:"address"`
	Contact          *string    `json:"contact"`
	ContactPhone     *string    `json:"contact_phone"`
	CreateAt         *time.Time `json:"create_at"`
	CreateBy         *string    `json:"create_by"`
	DeleteAt         *time.Time `json:"delete_at"`
	DeleteBy         *string    `json:"delete_by"`
	FactoryID        *string    `json:"factory_id"`
	FactoryName      *string    `json:"factory_name"`
	ID               *int64     `json:"id"`
	IsDelete         *bool      `json:"is_delete"`
	Remark           *string    `json:"remark"`
	TechContact      *string    `json:"tech_contact"`
	TechContactPhone *string    `json:"tech_contact_phone"`
	UpdateAt         *time.Time `json:"update_at"`
	UpdateBy         *string    `json:"update_by"`
}

// aggregate max on columns
type TerminalFactoryMaxFields struct {
	Address          *string    `json:"address"`
	Contact          *string    `json:"contact"`
	ContactPhone     *string    `json:"contact_phone"`
	CreateAt         *time.Time `json:"create_at"`
	CreateBy         *string    `json:"create_by"`
	DeleteAt         *time.Time `json:"delete_at"`
	DeleteBy         *string    `json:"delete_by"`
	FactoryID        *string    `json:"factory_id"`
	FactoryName      *string    `json:"factory_name"`
	ID               *int64     `json:"id"`
	Remark           *string    `json:"remark"`
	TechContact      *string    `json:"tech_contact"`
	TechContactPhone *string    `json:"tech_contact_phone"`
	UpdateAt         *time.Time `json:"update_at"`
	UpdateBy         *string    `json:"update_by"`
}

// order by max() on columns of table "terminal_factory"
type TerminalFactoryMaxOrderBy struct {
	Address          *model1.OrderBy `json:"address"`
	Contact          *model1.OrderBy `json:"contact"`
	ContactPhone     *model1.OrderBy `json:"contact_phone"`
	CreateAt         *model1.OrderBy `json:"create_at"`
	CreateBy         *model1.OrderBy `json:"create_by"`
	DeleteAt         *model1.OrderBy `json:"delete_at"`
	DeleteBy         *model1.OrderBy `json:"delete_by"`
	FactoryID        *model1.OrderBy `json:"factory_id"`
	FactoryName      *model1.OrderBy `json:"factory_name"`
	ID               *model1.OrderBy `json:"id"`
	Remark           *model1.OrderBy `json:"remark"`
	TechContact      *model1.OrderBy `json:"tech_contact"`
	TechContactPhone *model1.OrderBy `json:"tech_contact_phone"`
	UpdateAt         *model1.OrderBy `json:"update_at"`
	UpdateBy         *model1.OrderBy `json:"update_by"`
}

// aggregate min on columns
type TerminalFactoryMinFields struct {
	Address          *string    `json:"address"`
	Contact          *string    `json:"contact"`
	ContactPhone     *string    `json:"contact_phone"`
	CreateAt         *time.Time `json:"create_at"`
	CreateBy         *string    `json:"create_by"`
	DeleteAt         *time.Time `json:"delete_at"`
	DeleteBy         *string    `json:"delete_by"`
	FactoryID        *string    `json:"factory_id"`
	FactoryName      *string    `json:"factory_name"`
	ID               *int64     `json:"id"`
	Remark           *string    `json:"remark"`
	TechContact      *string    `json:"tech_contact"`
	TechContactPhone *string    `json:"tech_contact_phone"`
	UpdateAt         *time.Time `json:"update_at"`
	UpdateBy         *string    `json:"update_by"`
}

// order by min() on columns of table "terminal_factory"
type TerminalFactoryMinOrderBy struct {
	Address          *model1.OrderBy `json:"address"`
	Contact          *model1.OrderBy `json:"contact"`
	ContactPhone     *model1.OrderBy `json:"contact_phone"`
	CreateAt         *model1.OrderBy `json:"create_at"`
	CreateBy         *model1.OrderBy `json:"create_by"`
	DeleteAt         *model1.OrderBy `json:"delete_at"`
	DeleteBy         *model1.OrderBy `json:"delete_by"`
	FactoryID        *model1.OrderBy `json:"factory_id"`
	FactoryName      *model1.OrderBy `json:"factory_name"`
	ID               *model1.OrderBy `json:"id"`
	Remark           *model1.OrderBy `json:"remark"`
	TechContact      *model1.OrderBy `json:"tech_contact"`
	TechContactPhone *model1.OrderBy `json:"tech_contact_phone"`
	UpdateAt         *model1.OrderBy `json:"update_at"`
	UpdateBy         *model1.OrderBy `json:"update_by"`
}

// response of any mutation on the table "terminal_factory"
type TerminalFactoryMutationResponse struct {
	// number of affected rows by the mutation
	AffectedRows int `json:"affected_rows"`
	// data of the affected rows by the mutation
	Returning []*model.TerminalFactory `json:"returning"`
}

// input type for inserting object relation for remote table "terminal_factory"
type TerminalFactoryObjRelInsertInput struct {
	Data       *TerminalFactoryInsertInput `json:"data"`
	OnConflict *TerminalFactoryOnConflict  `json:"on_conflict"`
}

// on conflict condition type for table "terminal_factory"
type TerminalFactoryOnConflict struct {
	Constraint    TerminalFactoryConstraint     `json:"constraint"`
	UpdateColumns []TerminalFactoryUpdateColumn `json:"update_columns"`
	Where         *TerminalFactoryBoolExp       `json:"where"`
}

// ordering options when selecting data from "terminal_factory"
type TerminalFactoryOrderBy struct {
	Address          *model1.OrderBy `json:"address"`
	Contact          *model1.OrderBy `json:"contact"`
	ContactPhone     *model1.OrderBy `json:"contact_phone"`
	CreateAt         *model1.OrderBy `json:"create_at"`
	CreateBy         *model1.OrderBy `json:"create_by"`
	DeleteAt         *model1.OrderBy `json:"delete_at"`
	DeleteBy         *model1.OrderBy `json:"delete_by"`
	FactoryID        *model1.OrderBy `json:"factory_id"`
	FactoryName      *model1.OrderBy `json:"factory_name"`
	ID               *model1.OrderBy `json:"id"`
	IsDelete         *model1.OrderBy `json:"is_delete"`
	Remark           *model1.OrderBy `json:"remark"`
	TechContact      *model1.OrderBy `json:"tech_contact"`
	TechContactPhone *model1.OrderBy `json:"tech_contact_phone"`
	UpdateAt         *model1.OrderBy `json:"update_at"`
	UpdateBy         *model1.OrderBy `json:"update_by"`
}

// primary key columns input for table: "terminal_factory"
type TerminalFactoryPkColumnsInput struct {
	// ID
	ID int64 `json:"id"`
}

// input type for updating data in table "terminal_factory"
type TerminalFactorySetInput struct {
	Address          *string    `json:"address"`
	Contact          *string    `json:"contact"`
	ContactPhone     *string    `json:"contact_phone"`
	CreateAt         *time.Time `json:"create_at"`
	CreateBy         *string    `json:"create_by"`
	DeleteAt         *time.Time `json:"delete_at"`
	DeleteBy         *string    `json:"delete_by"`
	FactoryID        *string    `json:"factory_id"`
	FactoryName      *string    `json:"factory_name"`
	ID               *int64     `json:"id"`
	IsDelete         *bool      `json:"is_delete"`
	Remark           *string    `json:"remark"`
	TechContact      *string    `json:"tech_contact"`
	TechContactPhone *string    `json:"tech_contact_phone"`
	UpdateAt         *time.Time `json:"update_at"`
	UpdateBy         *string    `json:"update_by"`
}

// aggregate stddev on columns
type TerminalFactoryStddevFields struct {
	ID *float64 `json:"id"`
}

// order by stddev() on columns of table "terminal_factory"
type TerminalFactoryStddevOrderBy struct {
	ID *model1.OrderBy `json:"id"`
}

// aggregate stddev_pop on columns
type TerminalFactoryStddevPopFields struct {
	ID *float64 `json:"id"`
}

// order by stddev_pop() on columns of table "terminal_factory"
type TerminalFactoryStddevPopOrderBy struct {
	ID *model1.OrderBy `json:"id"`
}

// aggregate stddev_samp on columns
type TerminalFactoryStddevSampFields struct {
	ID *float64 `json:"id"`
}

// order by stddev_samp() on columns of table "terminal_factory"
type TerminalFactoryStddevSampOrderBy struct {
	ID *model1.OrderBy `json:"id"`
}

// aggregate sum on columns
type TerminalFactorySumFields struct {
	ID *int64 `json:"id"`
}

// order by sum() on columns of table "terminal_factory"
type TerminalFactorySumOrderBy struct {
	ID *model1.OrderBy `json:"id"`
}

// aggregate var_pop on columns
type TerminalFactoryVarPopFields struct {
	ID *float64 `json:"id"`
}

// order by var_pop() on columns of table "terminal_factory"
type TerminalFactoryVarPopOrderBy struct {
	ID *model1.OrderBy `json:"id"`
}

// aggregate var_samp on columns
type TerminalFactoryVarSampFields struct {
	ID *float64 `json:"id"`
}

// order by var_samp() on columns of table "terminal_factory"
type TerminalFactoryVarSampOrderBy struct {
	ID *model1.OrderBy `json:"id"`
}

// aggregate variance on columns
type TerminalFactoryVarianceFields struct {
	ID *float64 `json:"id"`
}

// order by variance() on columns of table "terminal_factory"
type TerminalFactoryVarianceOrderBy struct {
	ID *model1.OrderBy `json:"id"`
}

// input type for incrementing integer column in table "terminal"
type TerminalIncInput struct {
	CameraNum *int   `json:"camera_num"`
	ID        *int64 `json:"id"`
}

// input type for inserting data into table "terminal"
type TerminalInsertInput struct {
	AdasModel        *string    `json:"adas_model"`
	AuthKey          *string    `json:"auth_key"`
	CameraNum        *int       `json:"camera_num"`
	ChannelNo        *string    `json:"channel_no"`
	CityID           *string    `json:"city_id"`
	CreateAt         *time.Time `json:"create_at"`
	CreateBy         *string    `json:"create_by"`
	DeleteAt         *time.Time `json:"delete_at"`
	DeleteBy         *string    `json:"delete_by"`
	DeptID           *string    `json:"dept_id"`
	FirstInstallTime *time.Time `json:"first_install_time"`
	GuaranteeDate    *time.Time `json:"guarantee_date"`
	ID               *int64     `json:"id"`
	Imei             *string    `json:"imei"`
	InstallManID     *string    `json:"install_man_id"`
	IsDelete         *bool      `json:"is_delete"`
	IsReg            *bool      `json:"is_reg"`
	IsSupportPhoto   *bool      `json:"is_support_photo"`
	MockAuthKey      *string    `json:"mock_auth_key"`
	ProduceDate      *time.Time `json:"produce_date"`
	ProveProxyrgID   *string    `json:"prove_proxyrg_id"`
	ProvinceID       *string    `json:"province_id"`
	ProxyrgID        *string    `json:"proxyrg_id"`
	RecordDate       *time.Time `json:"record_date"`
	RegID            *string    `json:"reg_id"`
	Remarks          *string    `json:"remarks"`
	RemoveReason     *string    `json:"remove_reason"`
	SimID            *string    `json:"sim_id"`
	SprgID           *string    `json:"sprg_id"`
	TerminalID       *string    `json:"terminal_id"`
	TypeID           *string    `json:"type_id"`
	UpdateAt         *time.Time `json:"update_at"`
	UpdateBy         *string    `json:"update_by"`
	VehicleID        *string    `json:"vehicle_id"`
	VersionNumber    *string    `json:"version_number"`
}

// aggregate max on columns
type TerminalMaxFields struct {
	AdasModel        *string    `json:"adas_model"`
	AuthKey          *string    `json:"auth_key"`
	CameraNum        *int       `json:"camera_num"`
	ChannelNo        *string    `json:"channel_no"`
	CityID           *string    `json:"city_id"`
	CreateAt         *time.Time `json:"create_at"`
	CreateBy         *string    `json:"create_by"`
	DeleteAt         *time.Time `json:"delete_at"`
	DeleteBy         *string    `json:"delete_by"`
	DeptID           *string    `json:"dept_id"`
	FirstInstallTime *time.Time `json:"first_install_time"`
	GuaranteeDate    *time.Time `json:"guarantee_date"`
	ID               *int64     `json:"id"`
	Imei             *string    `json:"imei"`
	InstallManID     *string    `json:"install_man_id"`
	MockAuthKey      *string    `json:"mock_auth_key"`
	ProduceDate      *time.Time `json:"produce_date"`
	ProveProxyrgID   *string    `json:"prove_proxyrg_id"`
	ProvinceID       *string    `json:"province_id"`
	ProxyrgID        *string    `json:"proxyrg_id"`
	RecordDate       *time.Time `json:"record_date"`
	RegID            *string    `json:"reg_id"`
	Remarks          *string    `json:"remarks"`
	RemoveReason     *string    `json:"remove_reason"`
	SimID            *string    `json:"sim_id"`
	SprgID           *string    `json:"sprg_id"`
	TerminalID       *string    `json:"terminal_id"`
	TypeID           *string    `json:"type_id"`
	UpdateAt         *time.Time `json:"update_at"`
	UpdateBy         *string    `json:"update_by"`
	VehicleID        *string    `json:"vehicle_id"`
	VersionNumber    *string    `json:"version_number"`
}

// order by max() on columns of table "terminal"
type TerminalMaxOrderBy struct {
	AdasModel        *model1.OrderBy `json:"adas_model"`
	AuthKey          *model1.OrderBy `json:"auth_key"`
	CameraNum        *model1.OrderBy `json:"camera_num"`
	ChannelNo        *model1.OrderBy `json:"channel_no"`
	CityID           *model1.OrderBy `json:"city_id"`
	CreateAt         *model1.OrderBy `json:"create_at"`
	CreateBy         *model1.OrderBy `json:"create_by"`
	DeleteAt         *model1.OrderBy `json:"delete_at"`
	DeleteBy         *model1.OrderBy `json:"delete_by"`
	DeptID           *model1.OrderBy `json:"dept_id"`
	FirstInstallTime *model1.OrderBy `json:"first_install_time"`
	GuaranteeDate    *model1.OrderBy `json:"guarantee_date"`
	ID               *model1.OrderBy `json:"id"`
	Imei             *model1.OrderBy `json:"imei"`
	InstallManID     *model1.OrderBy `json:"install_man_id"`
	MockAuthKey      *model1.OrderBy `json:"mock_auth_key"`
	ProduceDate      *model1.OrderBy `json:"produce_date"`
	ProveProxyrgID   *model1.OrderBy `json:"prove_proxyrg_id"`
	ProvinceID       *model1.OrderBy `json:"province_id"`
	ProxyrgID        *model1.OrderBy `json:"proxyrg_id"`
	RecordDate       *model1.OrderBy `json:"record_date"`
	RegID            *model1.OrderBy `json:"reg_id"`
	Remarks          *model1.OrderBy `json:"remarks"`
	RemoveReason     *model1.OrderBy `json:"remove_reason"`
	SimID            *model1.OrderBy `json:"sim_id"`
	SprgID           *model1.OrderBy `json:"sprg_id"`
	TerminalID       *model1.OrderBy `json:"terminal_id"`
	TypeID           *model1.OrderBy `json:"type_id"`
	UpdateAt         *model1.OrderBy `json:"update_at"`
	UpdateBy         *model1.OrderBy `json:"update_by"`
	VehicleID        *model1.OrderBy `json:"vehicle_id"`
	VersionNumber    *model1.OrderBy `json:"version_number"`
}

// aggregate min on columns
type TerminalMinFields struct {
	AdasModel        *string    `json:"adas_model"`
	AuthKey          *string    `json:"auth_key"`
	CameraNum        *int       `json:"camera_num"`
	ChannelNo        *string    `json:"channel_no"`
	CityID           *string    `json:"city_id"`
	CreateAt         *time.Time `json:"create_at"`
	CreateBy         *string    `json:"create_by"`
	DeleteAt         *time.Time `json:"delete_at"`
	DeleteBy         *string    `json:"delete_by"`
	DeptID           *string    `json:"dept_id"`
	FirstInstallTime *time.Time `json:"first_install_time"`
	GuaranteeDate    *time.Time `json:"guarantee_date"`
	ID               *int64     `json:"id"`
	Imei             *string    `json:"imei"`
	InstallManID     *string    `json:"install_man_id"`
	MockAuthKey      *string    `json:"mock_auth_key"`
	ProduceDate      *time.Time `json:"produce_date"`
	ProveProxyrgID   *string    `json:"prove_proxyrg_id"`
	ProvinceID       *string    `json:"province_id"`
	ProxyrgID        *string    `json:"proxyrg_id"`
	RecordDate       *time.Time `json:"record_date"`
	RegID            *string    `json:"reg_id"`
	Remarks          *string    `json:"remarks"`
	RemoveReason     *string    `json:"remove_reason"`
	SimID            *string    `json:"sim_id"`
	SprgID           *string    `json:"sprg_id"`
	TerminalID       *string    `json:"terminal_id"`
	TypeID           *string    `json:"type_id"`
	UpdateAt         *time.Time `json:"update_at"`
	UpdateBy         *string    `json:"update_by"`
	VehicleID        *string    `json:"vehicle_id"`
	VersionNumber    *string    `json:"version_number"`
}

// order by min() on columns of table "terminal"
type TerminalMinOrderBy struct {
	AdasModel        *model1.OrderBy `json:"adas_model"`
	AuthKey          *model1.OrderBy `json:"auth_key"`
	CameraNum        *model1.OrderBy `json:"camera_num"`
	ChannelNo        *model1.OrderBy `json:"channel_no"`
	CityID           *model1.OrderBy `json:"city_id"`
	CreateAt         *model1.OrderBy `json:"create_at"`
	CreateBy         *model1.OrderBy `json:"create_by"`
	DeleteAt         *model1.OrderBy `json:"delete_at"`
	DeleteBy         *model1.OrderBy `json:"delete_by"`
	DeptID           *model1.OrderBy `json:"dept_id"`
	FirstInstallTime *model1.OrderBy `json:"first_install_time"`
	GuaranteeDate    *model1.OrderBy `json:"guarantee_date"`
	ID               *model1.OrderBy `json:"id"`
	Imei             *model1.OrderBy `json:"imei"`
	InstallManID     *model1.OrderBy `json:"install_man_id"`
	MockAuthKey      *model1.OrderBy `json:"mock_auth_key"`
	ProduceDate      *model1.OrderBy `json:"produce_date"`
	ProveProxyrgID   *model1.OrderBy `json:"prove_proxyrg_id"`
	ProvinceID       *model1.OrderBy `json:"province_id"`
	ProxyrgID        *model1.OrderBy `json:"proxyrg_id"`
	RecordDate       *model1.OrderBy `json:"record_date"`
	RegID            *model1.OrderBy `json:"reg_id"`
	Remarks          *model1.OrderBy `json:"remarks"`
	RemoveReason     *model1.OrderBy `json:"remove_reason"`
	SimID            *model1.OrderBy `json:"sim_id"`
	SprgID           *model1.OrderBy `json:"sprg_id"`
	TerminalID       *model1.OrderBy `json:"terminal_id"`
	TypeID           *model1.OrderBy `json:"type_id"`
	UpdateAt         *model1.OrderBy `json:"update_at"`
	UpdateBy         *model1.OrderBy `json:"update_by"`
	VehicleID        *model1.OrderBy `json:"vehicle_id"`
	VersionNumber    *model1.OrderBy `json:"version_number"`
}

// aggregated selection of "terminal_modal"
type TerminalModalAggregate struct {
	Aggregate *TerminalModalAggregateFields `json:"aggregate"`
	Nodes     []*model.TerminalModal        `json:"nodes"`
}

// aggregate fields of "terminal_modal"
type TerminalModalAggregateFields struct {
	Avg        *TerminalModalAvgFields        `json:"avg"`
	Count      *int                           `json:"count"`
	Max        *TerminalModalMaxFields        `json:"max"`
	Min        *TerminalModalMinFields        `json:"min"`
	Stddev     *TerminalModalStddevFields     `json:"stddev"`
	StddevPop  *TerminalModalStddevPopFields  `json:"stddev_pop"`
	StddevSamp *TerminalModalStddevSampFields `json:"stddev_samp"`
	Sum        *TerminalModalSumFields        `json:"sum"`
	VarPop     *TerminalModalVarPopFields     `json:"var_pop"`
	VarSamp    *TerminalModalVarSampFields    `json:"var_samp"`
	Variance   *TerminalModalVarianceFields   `json:"variance"`
}

// order by aggregate values of table "terminal_modal"
type TerminalModalAggregateOrderBy struct {
	Avg        *TerminalModalAvgOrderBy        `json:"avg"`
	Count      *model1.OrderBy                 `json:"count"`
	Max        *TerminalModalMaxOrderBy        `json:"max"`
	Min        *TerminalModalMinOrderBy        `json:"min"`
	Stddev     *TerminalModalStddevOrderBy     `json:"stddev"`
	StddevPop  *TerminalModalStddevPopOrderBy  `json:"stddev_pop"`
	StddevSamp *TerminalModalStddevSampOrderBy `json:"stddev_samp"`
	Sum        *TerminalModalSumOrderBy        `json:"sum"`
	VarPop     *TerminalModalVarPopOrderBy     `json:"var_pop"`
	VarSamp    *TerminalModalVarSampOrderBy    `json:"var_samp"`
	Variance   *TerminalModalVarianceOrderBy   `json:"variance"`
}

// input type for inserting array relation for remote table "terminal_modal"
type TerminalModalArrRelInsertInput struct {
	Data       []*TerminalModalInsertInput `json:"data"`
	OnConflict *TerminalModalOnConflict    `json:"on_conflict"`
}

// aggregate avg on columns
type TerminalModalAvgFields struct {
	ID *float64 `json:"id"`
}

// order by avg() on columns of table "terminal_modal"
type TerminalModalAvgOrderBy struct {
	ID *model1.OrderBy `json:"id"`
}

// Boolean expression to filter rows from the table "terminal_modal". All fields are combined with a logical 'AND'.
type TerminalModalBoolExp struct {
	And                   []*TerminalModalBoolExp          `json:"_and"`
	Not                   *TerminalModalBoolExp            `json:"_not"`
	Or                    []*TerminalModalBoolExp          `json:"_or"`
	AdasModal             *model1.StringComparisonExp      `json:"adas_modal"`
	CreateAt              *model1.TimestamptzComparisonExp `json:"create_at"`
	CreateBy              *model1.StringComparisonExp      `json:"create_by"`
	DeleteAt              *model1.TimestamptzComparisonExp `json:"delete_at"`
	DeleteBy              *model1.StringComparisonExp      `json:"delete_by"`
	FactoryID             *model1.StringComparisonExp      `json:"factory_id"`
	ID                    *model1.BigintComparisonExp      `json:"id"`
	IsDelete              *model1.BooleanComparisonExp     `json:"is_delete"`
	IsElectronicsPostCard *model1.BooleanComparisonExp     `json:"is_electronics_post_card"`
	IsSlagCarTeminal      *model1.BooleanComparisonExp     `json:"is_slag_car_teminal"`
	IsTestingSituation    *model1.BooleanComparisonExp     `json:"is_testing_situation"`
	IsTransportDept4g     *model1.BooleanComparisonExp     `json:"is_transport_dept_4g"`
	ModalName             *model1.StringComparisonExp      `json:"modal_name"`
	ProxyrgID             *model1.StringComparisonExp      `json:"proxyrg_id"`
	RecordNo              *model1.StringComparisonExp      `json:"record_no"`
	Remark                *model1.StringComparisonExp      `json:"remark"`
	TerminalModalID       *model1.StringComparisonExp      `json:"terminal_modal_id"`
	TerminalTypeID        *model1.StringComparisonExp      `json:"terminal_type_id"`
	UpdateAt              *model1.TimestamptzComparisonExp `json:"update_at"`
	UpdateBy              *model1.StringComparisonExp      `json:"update_by"`
}

// input type for incrementing integer column in table "terminal_modal"
type TerminalModalIncInput struct {
	ID *int64 `json:"id"`
}

// input type for inserting data into table "terminal_modal"
type TerminalModalInsertInput struct {
	AdasModal             *string    `json:"adas_modal"`
	CreateAt              *time.Time `json:"create_at"`
	CreateBy              *string    `json:"create_by"`
	DeleteAt              *time.Time `json:"delete_at"`
	DeleteBy              *string    `json:"delete_by"`
	FactoryID             *string    `json:"factory_id"`
	ID                    *int64     `json:"id"`
	IsDelete              *bool      `json:"is_delete"`
	IsElectronicsPostCard *bool      `json:"is_electronics_post_card"`
	IsSlagCarTeminal      *bool      `json:"is_slag_car_teminal"`
	IsTestingSituation    *bool      `json:"is_testing_situation"`
	IsTransportDept4g     *bool      `json:"is_transport_dept_4g"`
	ModalName             *string    `json:"modal_name"`
	ProxyrgID             *string    `json:"proxyrg_id"`
	RecordNo              *string    `json:"record_no"`
	Remark                *string    `json:"remark"`
	TerminalModalID       *string    `json:"terminal_modal_id"`
	TerminalTypeID        *string    `json:"terminal_type_id"`
	UpdateAt              *time.Time `json:"update_at"`
	UpdateBy              *string    `json:"update_by"`
}

// aggregate max on columns
type TerminalModalMaxFields struct {
	AdasModal       *string    `json:"adas_modal"`
	CreateAt        *time.Time `json:"create_at"`
	CreateBy        *string    `json:"create_by"`
	DeleteAt        *time.Time `json:"delete_at"`
	DeleteBy        *string    `json:"delete_by"`
	FactoryID       *string    `json:"factory_id"`
	ID              *int64     `json:"id"`
	ModalName       *string    `json:"modal_name"`
	ProxyrgID       *string    `json:"proxyrg_id"`
	RecordNo        *string    `json:"record_no"`
	Remark          *string    `json:"remark"`
	TerminalModalID *string    `json:"terminal_modal_id"`
	TerminalTypeID  *string    `json:"terminal_type_id"`
	UpdateAt        *time.Time `json:"update_at"`
	UpdateBy        *string    `json:"update_by"`
}

// order by max() on columns of table "terminal_modal"
type TerminalModalMaxOrderBy struct {
	AdasModal       *model1.OrderBy `json:"adas_modal"`
	CreateAt        *model1.OrderBy `json:"create_at"`
	CreateBy        *model1.OrderBy `json:"create_by"`
	DeleteAt        *model1.OrderBy `json:"delete_at"`
	DeleteBy        *model1.OrderBy `json:"delete_by"`
	FactoryID       *model1.OrderBy `json:"factory_id"`
	ID              *model1.OrderBy `json:"id"`
	ModalName       *model1.OrderBy `json:"modal_name"`
	ProxyrgID       *model1.OrderBy `json:"proxyrg_id"`
	RecordNo        *model1.OrderBy `json:"record_no"`
	Remark          *model1.OrderBy `json:"remark"`
	TerminalModalID *model1.OrderBy `json:"terminal_modal_id"`
	TerminalTypeID  *model1.OrderBy `json:"terminal_type_id"`
	UpdateAt        *model1.OrderBy `json:"update_at"`
	UpdateBy        *model1.OrderBy `json:"update_by"`
}

// aggregate min on columns
type TerminalModalMinFields struct {
	AdasModal       *string    `json:"adas_modal"`
	CreateAt        *time.Time `json:"create_at"`
	CreateBy        *string    `json:"create_by"`
	DeleteAt        *time.Time `json:"delete_at"`
	DeleteBy        *string    `json:"delete_by"`
	FactoryID       *string    `json:"factory_id"`
	ID              *int64     `json:"id"`
	ModalName       *string    `json:"modal_name"`
	ProxyrgID       *string    `json:"proxyrg_id"`
	RecordNo        *string    `json:"record_no"`
	Remark          *string    `json:"remark"`
	TerminalModalID *string    `json:"terminal_modal_id"`
	TerminalTypeID  *string    `json:"terminal_type_id"`
	UpdateAt        *time.Time `json:"update_at"`
	UpdateBy        *string    `json:"update_by"`
}

// order by min() on columns of table "terminal_modal"
type TerminalModalMinOrderBy struct {
	AdasModal       *model1.OrderBy `json:"adas_modal"`
	CreateAt        *model1.OrderBy `json:"create_at"`
	CreateBy        *model1.OrderBy `json:"create_by"`
	DeleteAt        *model1.OrderBy `json:"delete_at"`
	DeleteBy        *model1.OrderBy `json:"delete_by"`
	FactoryID       *model1.OrderBy `json:"factory_id"`
	ID              *model1.OrderBy `json:"id"`
	ModalName       *model1.OrderBy `json:"modal_name"`
	ProxyrgID       *model1.OrderBy `json:"proxyrg_id"`
	RecordNo        *model1.OrderBy `json:"record_no"`
	Remark          *model1.OrderBy `json:"remark"`
	TerminalModalID *model1.OrderBy `json:"terminal_modal_id"`
	TerminalTypeID  *model1.OrderBy `json:"terminal_type_id"`
	UpdateAt        *model1.OrderBy `json:"update_at"`
	UpdateBy        *model1.OrderBy `json:"update_by"`
}

// response of any mutation on the table "terminal_modal"
type TerminalModalMutationResponse struct {
	// number of affected rows by the mutation
	AffectedRows int `json:"affected_rows"`
	// data of the affected rows by the mutation
	Returning []*model.TerminalModal `json:"returning"`
}

// input type for inserting object relation for remote table "terminal_modal"
type TerminalModalObjRelInsertInput struct {
	Data       *TerminalModalInsertInput `json:"data"`
	OnConflict *TerminalModalOnConflict  `json:"on_conflict"`
}

// on conflict condition type for table "terminal_modal"
type TerminalModalOnConflict struct {
	Constraint    TerminalModalConstraint     `json:"constraint"`
	UpdateColumns []TerminalModalUpdateColumn `json:"update_columns"`
	Where         *TerminalModalBoolExp       `json:"where"`
}

// ordering options when selecting data from "terminal_modal"
type TerminalModalOrderBy struct {
	AdasModal             *model1.OrderBy `json:"adas_modal"`
	CreateAt              *model1.OrderBy `json:"create_at"`
	CreateBy              *model1.OrderBy `json:"create_by"`
	DeleteAt              *model1.OrderBy `json:"delete_at"`
	DeleteBy              *model1.OrderBy `json:"delete_by"`
	FactoryID             *model1.OrderBy `json:"factory_id"`
	ID                    *model1.OrderBy `json:"id"`
	IsDelete              *model1.OrderBy `json:"is_delete"`
	IsElectronicsPostCard *model1.OrderBy `json:"is_electronics_post_card"`
	IsSlagCarTeminal      *model1.OrderBy `json:"is_slag_car_teminal"`
	IsTestingSituation    *model1.OrderBy `json:"is_testing_situation"`
	IsTransportDept4g     *model1.OrderBy `json:"is_transport_dept_4g"`
	ModalName             *model1.OrderBy `json:"modal_name"`
	ProxyrgID             *model1.OrderBy `json:"proxyrg_id"`
	RecordNo              *model1.OrderBy `json:"record_no"`
	Remark                *model1.OrderBy `json:"remark"`
	TerminalModalID       *model1.OrderBy `json:"terminal_modal_id"`
	TerminalTypeID        *model1.OrderBy `json:"terminal_type_id"`
	UpdateAt              *model1.OrderBy `json:"update_at"`
	UpdateBy              *model1.OrderBy `json:"update_by"`
}

// primary key columns input for table: "terminal_modal"
type TerminalModalPkColumnsInput struct {
	// ID
	ID int64 `json:"id"`
}

// input type for updating data in table "terminal_modal"
type TerminalModalSetInput struct {
	AdasModal             *string    `json:"adas_modal"`
	CreateAt              *time.Time `json:"create_at"`
	CreateBy              *string    `json:"create_by"`
	DeleteAt              *time.Time `json:"delete_at"`
	DeleteBy              *string    `json:"delete_by"`
	FactoryID             *string    `json:"factory_id"`
	ID                    *int64     `json:"id"`
	IsDelete              *bool      `json:"is_delete"`
	IsElectronicsPostCard *bool      `json:"is_electronics_post_card"`
	IsSlagCarTeminal      *bool      `json:"is_slag_car_teminal"`
	IsTestingSituation    *bool      `json:"is_testing_situation"`
	IsTransportDept4g     *bool      `json:"is_transport_dept_4g"`
	ModalName             *string    `json:"modal_name"`
	ProxyrgID             *string    `json:"proxyrg_id"`
	RecordNo              *string    `json:"record_no"`
	Remark                *string    `json:"remark"`
	TerminalModalID       *string    `json:"terminal_modal_id"`
	TerminalTypeID        *string    `json:"terminal_type_id"`
	UpdateAt              *time.Time `json:"update_at"`
	UpdateBy              *string    `json:"update_by"`
}

// aggregate stddev on columns
type TerminalModalStddevFields struct {
	ID *float64 `json:"id"`
}

// order by stddev() on columns of table "terminal_modal"
type TerminalModalStddevOrderBy struct {
	ID *model1.OrderBy `json:"id"`
}

// aggregate stddev_pop on columns
type TerminalModalStddevPopFields struct {
	ID *float64 `json:"id"`
}

// order by stddev_pop() on columns of table "terminal_modal"
type TerminalModalStddevPopOrderBy struct {
	ID *model1.OrderBy `json:"id"`
}

// aggregate stddev_samp on columns
type TerminalModalStddevSampFields struct {
	ID *float64 `json:"id"`
}

// order by stddev_samp() on columns of table "terminal_modal"
type TerminalModalStddevSampOrderBy struct {
	ID *model1.OrderBy `json:"id"`
}

// aggregate sum on columns
type TerminalModalSumFields struct {
	ID *int64 `json:"id"`
}

// order by sum() on columns of table "terminal_modal"
type TerminalModalSumOrderBy struct {
	ID *model1.OrderBy `json:"id"`
}

// aggregate var_pop on columns
type TerminalModalVarPopFields struct {
	ID *float64 `json:"id"`
}

// order by var_pop() on columns of table "terminal_modal"
type TerminalModalVarPopOrderBy struct {
	ID *model1.OrderBy `json:"id"`
}

// aggregate var_samp on columns
type TerminalModalVarSampFields struct {
	ID *float64 `json:"id"`
}

// order by var_samp() on columns of table "terminal_modal"
type TerminalModalVarSampOrderBy struct {
	ID *model1.OrderBy `json:"id"`
}

// aggregate variance on columns
type TerminalModalVarianceFields struct {
	ID *float64 `json:"id"`
}

// order by variance() on columns of table "terminal_modal"
type TerminalModalVarianceOrderBy struct {
	ID *model1.OrderBy `json:"id"`
}

// response of any mutation on the table "terminal"
type TerminalMutationResponse struct {
	// number of affected rows by the mutation
	AffectedRows int `json:"affected_rows"`
	// data of the affected rows by the mutation
	Returning []*model.Terminal `json:"returning"`
}

// input type for inserting object relation for remote table "terminal"
type TerminalObjRelInsertInput struct {
	Data       *TerminalInsertInput `json:"data"`
	OnConflict *TerminalOnConflict  `json:"on_conflict"`
}

// on conflict condition type for table "terminal"
type TerminalOnConflict struct {
	Constraint    TerminalConstraint     `json:"constraint"`
	UpdateColumns []TerminalUpdateColumn `json:"update_columns"`
	Where         *TerminalBoolExp       `json:"where"`
}

// ordering options when selecting data from "terminal"
type TerminalOrderBy struct {
	AdasModel        *model1.OrderBy `json:"adas_model"`
	AuthKey          *model1.OrderBy `json:"auth_key"`
	CameraNum        *model1.OrderBy `json:"camera_num"`
	ChannelNo        *model1.OrderBy `json:"channel_no"`
	CityID           *model1.OrderBy `json:"city_id"`
	CreateAt         *model1.OrderBy `json:"create_at"`
	CreateBy         *model1.OrderBy `json:"create_by"`
	DeleteAt         *model1.OrderBy `json:"delete_at"`
	DeleteBy         *model1.OrderBy `json:"delete_by"`
	DeptID           *model1.OrderBy `json:"dept_id"`
	FirstInstallTime *model1.OrderBy `json:"first_install_time"`
	GuaranteeDate    *model1.OrderBy `json:"guarantee_date"`
	ID               *model1.OrderBy `json:"id"`
	Imei             *model1.OrderBy `json:"imei"`
	InstallManID     *model1.OrderBy `json:"install_man_id"`
	IsDelete         *model1.OrderBy `json:"is_delete"`
	IsReg            *model1.OrderBy `json:"is_reg"`
	IsSupportPhoto   *model1.OrderBy `json:"is_support_photo"`
	MockAuthKey      *model1.OrderBy `json:"mock_auth_key"`
	ProduceDate      *model1.OrderBy `json:"produce_date"`
	ProveProxyrgID   *model1.OrderBy `json:"prove_proxyrg_id"`
	ProvinceID       *model1.OrderBy `json:"province_id"`
	ProxyrgID        *model1.OrderBy `json:"proxyrg_id"`
	RecordDate       *model1.OrderBy `json:"record_date"`
	RegID            *model1.OrderBy `json:"reg_id"`
	Remarks          *model1.OrderBy `json:"remarks"`
	RemoveReason     *model1.OrderBy `json:"remove_reason"`
	SimID            *model1.OrderBy `json:"sim_id"`
	SprgID           *model1.OrderBy `json:"sprg_id"`
	TerminalID       *model1.OrderBy `json:"terminal_id"`
	TypeID           *model1.OrderBy `json:"type_id"`
	UpdateAt         *model1.OrderBy `json:"update_at"`
	UpdateBy         *model1.OrderBy `json:"update_by"`
	VehicleID        *model1.OrderBy `json:"vehicle_id"`
	VersionNumber    *model1.OrderBy `json:"version_number"`
}

// primary key columns input for table: "terminal"
type TerminalPkColumnsInput struct {
	// ID
	ID int64 `json:"id"`
}

// input type for updating data in table "terminal"
type TerminalSetInput struct {
	AdasModel        *string    `json:"adas_model"`
	AuthKey          *string    `json:"auth_key"`
	CameraNum        *int       `json:"camera_num"`
	ChannelNo        *string    `json:"channel_no"`
	CityID           *string    `json:"city_id"`
	CreateAt         *time.Time `json:"create_at"`
	CreateBy         *string    `json:"create_by"`
	DeleteAt         *time.Time `json:"delete_at"`
	DeleteBy         *string    `json:"delete_by"`
	DeptID           *string    `json:"dept_id"`
	FirstInstallTime *time.Time `json:"first_install_time"`
	GuaranteeDate    *time.Time `json:"guarantee_date"`
	ID               *int64     `json:"id"`
	Imei             *string    `json:"imei"`
	InstallManID     *string    `json:"install_man_id"`
	IsDelete         *bool      `json:"is_delete"`
	IsReg            *bool      `json:"is_reg"`
	IsSupportPhoto   *bool      `json:"is_support_photo"`
	MockAuthKey      *string    `json:"mock_auth_key"`
	ProduceDate      *time.Time `json:"produce_date"`
	ProveProxyrgID   *string    `json:"prove_proxyrg_id"`
	ProvinceID       *string    `json:"province_id"`
	ProxyrgID        *string    `json:"proxyrg_id"`
	RecordDate       *time.Time `json:"record_date"`
	RegID            *string    `json:"reg_id"`
	Remarks          *string    `json:"remarks"`
	RemoveReason     *string    `json:"remove_reason"`
	SimID            *string    `json:"sim_id"`
	SprgID           *string    `json:"sprg_id"`
	TerminalID       *string    `json:"terminal_id"`
	TypeID           *string    `json:"type_id"`
	UpdateAt         *time.Time `json:"update_at"`
	UpdateBy         *string    `json:"update_by"`
	VehicleID        *string    `json:"vehicle_id"`
	VersionNumber    *string    `json:"version_number"`
}

// aggregate stddev on columns
type TerminalStddevFields struct {
	CameraNum *float64 `json:"camera_num"`
	ID        *float64 `json:"id"`
}

// order by stddev() on columns of table "terminal"
type TerminalStddevOrderBy struct {
	CameraNum *model1.OrderBy `json:"camera_num"`
	ID        *model1.OrderBy `json:"id"`
}

// aggregate stddev_pop on columns
type TerminalStddevPopFields struct {
	CameraNum *float64 `json:"camera_num"`
	ID        *float64 `json:"id"`
}

// order by stddev_pop() on columns of table "terminal"
type TerminalStddevPopOrderBy struct {
	CameraNum *model1.OrderBy `json:"camera_num"`
	ID        *model1.OrderBy `json:"id"`
}

// aggregate stddev_samp on columns
type TerminalStddevSampFields struct {
	CameraNum *float64 `json:"camera_num"`
	ID        *float64 `json:"id"`
}

// order by stddev_samp() on columns of table "terminal"
type TerminalStddevSampOrderBy struct {
	CameraNum *model1.OrderBy `json:"camera_num"`
	ID        *model1.OrderBy `json:"id"`
}

// aggregate sum on columns
type TerminalSumFields struct {
	CameraNum *int   `json:"camera_num"`
	ID        *int64 `json:"id"`
}

// order by sum() on columns of table "terminal"
type TerminalSumOrderBy struct {
	CameraNum *model1.OrderBy `json:"camera_num"`
	ID        *model1.OrderBy `json:"id"`
}

// aggregated selection of "terminal_types"
type TerminalTypesAggregate struct {
	Aggregate *TerminalTypesAggregateFields `json:"aggregate"`
	Nodes     []*model.TerminalType         `json:"nodes"`
}

// aggregate fields of "terminal_types"
type TerminalTypesAggregateFields struct {
	Avg        *TerminalTypesAvgFields        `json:"avg"`
	Count      *int                           `json:"count"`
	Max        *TerminalTypesMaxFields        `json:"max"`
	Min        *TerminalTypesMinFields        `json:"min"`
	Stddev     *TerminalTypesStddevFields     `json:"stddev"`
	StddevPop  *TerminalTypesStddevPopFields  `json:"stddev_pop"`
	StddevSamp *TerminalTypesStddevSampFields `json:"stddev_samp"`
	Sum        *TerminalTypesSumFields        `json:"sum"`
	VarPop     *TerminalTypesVarPopFields     `json:"var_pop"`
	VarSamp    *TerminalTypesVarSampFields    `json:"var_samp"`
	Variance   *TerminalTypesVarianceFields   `json:"variance"`
}

// order by aggregate values of table "terminal_types"
type TerminalTypesAggregateOrderBy struct {
	Avg        *TerminalTypesAvgOrderBy        `json:"avg"`
	Count      *model1.OrderBy                 `json:"count"`
	Max        *TerminalTypesMaxOrderBy        `json:"max"`
	Min        *TerminalTypesMinOrderBy        `json:"min"`
	Stddev     *TerminalTypesStddevOrderBy     `json:"stddev"`
	StddevPop  *TerminalTypesStddevPopOrderBy  `json:"stddev_pop"`
	StddevSamp *TerminalTypesStddevSampOrderBy `json:"stddev_samp"`
	Sum        *TerminalTypesSumOrderBy        `json:"sum"`
	VarPop     *TerminalTypesVarPopOrderBy     `json:"var_pop"`
	VarSamp    *TerminalTypesVarSampOrderBy    `json:"var_samp"`
	Variance   *TerminalTypesVarianceOrderBy   `json:"variance"`
}

// input type for inserting array relation for remote table "terminal_types"
type TerminalTypesArrRelInsertInput struct {
	Data       []*TerminalTypesInsertInput `json:"data"`
	OnConflict *TerminalTypesOnConflict    `json:"on_conflict"`
}

// aggregate avg on columns
type TerminalTypesAvgFields struct {
	ID *float64 `json:"id"`
}

// order by avg() on columns of table "terminal_types"
type TerminalTypesAvgOrderBy struct {
	ID *model1.OrderBy `json:"id"`
}

// Boolean expression to filter rows from the table "terminal_types". All fields are combined with a logical 'AND'.
type TerminalTypesBoolExp struct {
	And          []*TerminalTypesBoolExp          `json:"_and"`
	Not          *TerminalTypesBoolExp            `json:"_not"`
	Or           []*TerminalTypesBoolExp          `json:"_or"`
	CreateAt     *model1.TimestamptzComparisonExp `json:"create_at"`
	CreateBy     *model1.StringComparisonExp      `json:"create_by"`
	DeleteAt     *model1.TimestamptzComparisonExp `json:"delete_at"`
	DeleteBy     *model1.StringComparisonExp      `json:"delete_by"`
	ID           *model1.BigintComparisonExp      `json:"id"`
	IsDelete     *model1.BooleanComparisonExp     `json:"is_delete"`
	ProtocolName *model1.StringComparisonExp      `json:"protocol_name"`
	Remark       *model1.StringComparisonExp      `json:"remark"`
	TypeID       *model1.StringComparisonExp      `json:"type_id"`
	UpdateAt     *model1.TimestamptzComparisonExp `json:"update_at"`
	UpdateBy     *model1.StringComparisonExp      `json:"update_by"`
}

// input type for incrementing integer column in table "terminal_types"
type TerminalTypesIncInput struct {
	ID *int64 `json:"id"`
}

// input type for inserting data into table "terminal_types"
type TerminalTypesInsertInput struct {
	CreateAt     *time.Time `json:"create_at"`
	CreateBy     *string    `json:"create_by"`
	DeleteAt     *time.Time `json:"delete_at"`
	DeleteBy     *string    `json:"delete_by"`
	ID           *int64     `json:"id"`
	IsDelete     *bool      `json:"is_delete"`
	ProtocolName *string    `json:"protocol_name"`
	Remark       *string    `json:"remark"`
	TypeID       *string    `json:"type_id"`
	UpdateAt     *time.Time `json:"update_at"`
	UpdateBy     *string    `json:"update_by"`
}

// aggregate max on columns
type TerminalTypesMaxFields struct {
	CreateAt     *time.Time `json:"create_at"`
	CreateBy     *string    `json:"create_by"`
	DeleteAt     *time.Time `json:"delete_at"`
	DeleteBy     *string    `json:"delete_by"`
	ID           *int64     `json:"id"`
	ProtocolName *string    `json:"protocol_name"`
	Remark       *string    `json:"remark"`
	TypeID       *string    `json:"type_id"`
	UpdateAt     *time.Time `json:"update_at"`
	UpdateBy     *string    `json:"update_by"`
}

// order by max() on columns of table "terminal_types"
type TerminalTypesMaxOrderBy struct {
	CreateAt     *model1.OrderBy `json:"create_at"`
	CreateBy     *model1.OrderBy `json:"create_by"`
	DeleteAt     *model1.OrderBy `json:"delete_at"`
	DeleteBy     *model1.OrderBy `json:"delete_by"`
	ID           *model1.OrderBy `json:"id"`
	ProtocolName *model1.OrderBy `json:"protocol_name"`
	Remark       *model1.OrderBy `json:"remark"`
	TypeID       *model1.OrderBy `json:"type_id"`
	UpdateAt     *model1.OrderBy `json:"update_at"`
	UpdateBy     *model1.OrderBy `json:"update_by"`
}

// aggregate min on columns
type TerminalTypesMinFields struct {
	CreateAt     *time.Time `json:"create_at"`
	CreateBy     *string    `json:"create_by"`
	DeleteAt     *time.Time `json:"delete_at"`
	DeleteBy     *string    `json:"delete_by"`
	ID           *int64     `json:"id"`
	ProtocolName *string    `json:"protocol_name"`
	Remark       *string    `json:"remark"`
	TypeID       *string    `json:"type_id"`
	UpdateAt     *time.Time `json:"update_at"`
	UpdateBy     *string    `json:"update_by"`
}

// order by min() on columns of table "terminal_types"
type TerminalTypesMinOrderBy struct {
	CreateAt     *model1.OrderBy `json:"create_at"`
	CreateBy     *model1.OrderBy `json:"create_by"`
	DeleteAt     *model1.OrderBy `json:"delete_at"`
	DeleteBy     *model1.OrderBy `json:"delete_by"`
	ID           *model1.OrderBy `json:"id"`
	ProtocolName *model1.OrderBy `json:"protocol_name"`
	Remark       *model1.OrderBy `json:"remark"`
	TypeID       *model1.OrderBy `json:"type_id"`
	UpdateAt     *model1.OrderBy `json:"update_at"`
	UpdateBy     *model1.OrderBy `json:"update_by"`
}

// response of any mutation on the table "terminal_types"
type TerminalTypesMutationResponse struct {
	// number of affected rows by the mutation
	AffectedRows int `json:"affected_rows"`
	// data of the affected rows by the mutation
	Returning []*model.TerminalType `json:"returning"`
}

// input type for inserting object relation for remote table "terminal_types"
type TerminalTypesObjRelInsertInput struct {
	Data       *TerminalTypesInsertInput `json:"data"`
	OnConflict *TerminalTypesOnConflict  `json:"on_conflict"`
}

// on conflict condition type for table "terminal_types"
type TerminalTypesOnConflict struct {
	Constraint    TerminalTypesConstraint     `json:"constraint"`
	UpdateColumns []TerminalTypesUpdateColumn `json:"update_columns"`
	Where         *TerminalTypesBoolExp       `json:"where"`
}

// ordering options when selecting data from "terminal_types"
type TerminalTypesOrderBy struct {
	CreateAt     *model1.OrderBy `json:"create_at"`
	CreateBy     *model1.OrderBy `json:"create_by"`
	DeleteAt     *model1.OrderBy `json:"delete_at"`
	DeleteBy     *model1.OrderBy `json:"delete_by"`
	ID           *model1.OrderBy `json:"id"`
	IsDelete     *model1.OrderBy `json:"is_delete"`
	ProtocolName *model1.OrderBy `json:"protocol_name"`
	Remark       *model1.OrderBy `json:"remark"`
	TypeID       *model1.OrderBy `json:"type_id"`
	UpdateAt     *model1.OrderBy `json:"update_at"`
	UpdateBy     *model1.OrderBy `json:"update_by"`
}

// primary key columns input for table: "terminal_types"
type TerminalTypesPkColumnsInput struct {
	// ID
	ID int64 `json:"id"`
}

// input type for updating data in table "terminal_types"
type TerminalTypesSetInput struct {
	CreateAt     *time.Time `json:"create_at"`
	CreateBy     *string    `json:"create_by"`
	DeleteAt     *time.Time `json:"delete_at"`
	DeleteBy     *string    `json:"delete_by"`
	ID           *int64     `json:"id"`
	IsDelete     *bool      `json:"is_delete"`
	ProtocolName *string    `json:"protocol_name"`
	Remark       *string    `json:"remark"`
	TypeID       *string    `json:"type_id"`
	UpdateAt     *time.Time `json:"update_at"`
	UpdateBy     *string    `json:"update_by"`
}

// aggregate stddev on columns
type TerminalTypesStddevFields struct {
	ID *float64 `json:"id"`
}

// order by stddev() on columns of table "terminal_types"
type TerminalTypesStddevOrderBy struct {
	ID *model1.OrderBy `json:"id"`
}

// aggregate stddev_pop on columns
type TerminalTypesStddevPopFields struct {
	ID *float64 `json:"id"`
}

// order by stddev_pop() on columns of table "terminal_types"
type TerminalTypesStddevPopOrderBy struct {
	ID *model1.OrderBy `json:"id"`
}

// aggregate stddev_samp on columns
type TerminalTypesStddevSampFields struct {
	ID *float64 `json:"id"`
}

// order by stddev_samp() on columns of table "terminal_types"
type TerminalTypesStddevSampOrderBy struct {
	ID *model1.OrderBy `json:"id"`
}

// aggregate sum on columns
type TerminalTypesSumFields struct {
	ID *int64 `json:"id"`
}

// order by sum() on columns of table "terminal_types"
type TerminalTypesSumOrderBy struct {
	ID *model1.OrderBy `json:"id"`
}

// aggregate var_pop on columns
type TerminalTypesVarPopFields struct {
	ID *float64 `json:"id"`
}

// order by var_pop() on columns of table "terminal_types"
type TerminalTypesVarPopOrderBy struct {
	ID *model1.OrderBy `json:"id"`
}

// aggregate var_samp on columns
type TerminalTypesVarSampFields struct {
	ID *float64 `json:"id"`
}

// order by var_samp() on columns of table "terminal_types"
type TerminalTypesVarSampOrderBy struct {
	ID *model1.OrderBy `json:"id"`
}

// aggregate variance on columns
type TerminalTypesVarianceFields struct {
	ID *float64 `json:"id"`
}

// order by variance() on columns of table "terminal_types"
type TerminalTypesVarianceOrderBy struct {
	ID *model1.OrderBy `json:"id"`
}

// aggregate var_pop on columns
type TerminalVarPopFields struct {
	CameraNum *float64 `json:"camera_num"`
	ID        *float64 `json:"id"`
}

// order by var_pop() on columns of table "terminal"
type TerminalVarPopOrderBy struct {
	CameraNum *model1.OrderBy `json:"camera_num"`
	ID        *model1.OrderBy `json:"id"`
}

// aggregate var_samp on columns
type TerminalVarSampFields struct {
	CameraNum *float64 `json:"camera_num"`
	ID        *float64 `json:"id"`
}

// order by var_samp() on columns of table "terminal"
type TerminalVarSampOrderBy struct {
	CameraNum *model1.OrderBy `json:"camera_num"`
	ID        *model1.OrderBy `json:"id"`
}

// aggregate variance on columns
type TerminalVarianceFields struct {
	CameraNum *float64 `json:"camera_num"`
	ID        *float64 `json:"id"`
}

// order by variance() on columns of table "terminal"
type TerminalVarianceOrderBy struct {
	CameraNum *model1.OrderBy `json:"camera_num"`
	ID        *model1.OrderBy `json:"id"`
}

// unique or primary key constraints on table "sim_card"
type SimCardConstraint string

const (
	// unique or primary key constraint
	SimCardConstraintSimCardPkey SimCardConstraint = "sim_card_pkey"
)

var AllSimCardConstraint = []SimCardConstraint{
	SimCardConstraintSimCardPkey,
}

func (e SimCardConstraint) IsValid() bool {
	switch e {
	case SimCardConstraintSimCardPkey:
		return true
	}
	return false
}

func (e SimCardConstraint) String() string {
	return string(e)
}

func (e *SimCardConstraint) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SimCardConstraint(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid sim_card_constraint", str)
	}
	return nil
}

func (e SimCardConstraint) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// unique or primary key constraints on table "sim_card_flow"
type SimCardFlowConstraint string

const (
	// unique or primary key constraint
	SimCardFlowConstraintSimCardFlowPkey SimCardFlowConstraint = "sim_card_flow_pkey"
)

var AllSimCardFlowConstraint = []SimCardFlowConstraint{
	SimCardFlowConstraintSimCardFlowPkey,
}

func (e SimCardFlowConstraint) IsValid() bool {
	switch e {
	case SimCardFlowConstraintSimCardFlowPkey:
		return true
	}
	return false
}

func (e SimCardFlowConstraint) String() string {
	return string(e)
}

func (e *SimCardFlowConstraint) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SimCardFlowConstraint(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid sim_card_flow_constraint", str)
	}
	return nil
}

func (e SimCardFlowConstraint) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// select columns of table "sim_card_flow"
type SimCardFlowSelectColumn string

const (
	// column name
	SimCardFlowSelectColumnCardAvgFlow SimCardFlowSelectColumn = "card_avg_flow"
	// column name
	SimCardFlowSelectColumnCardNoRemark SimCardFlowSelectColumn = "card_no_remark"
	// column name
	SimCardFlowSelectColumnCreateAt SimCardFlowSelectColumn = "create_at"
	// column name
	SimCardFlowSelectColumnCreateBy SimCardFlowSelectColumn = "create_by"
	// column name
	SimCardFlowSelectColumnDeleteAt SimCardFlowSelectColumn = "delete_at"
	// column name
	SimCardFlowSelectColumnDeleteBy SimCardFlowSelectColumn = "delete_by"
	// column name
	SimCardFlowSelectColumnEnterpriseID SimCardFlowSelectColumn = "enterprise_id"
	// column name
	SimCardFlowSelectColumnIccid SimCardFlowSelectColumn = "iccid"
	// column name
	SimCardFlowSelectColumnID SimCardFlowSelectColumn = "id"
	// column name
	SimCardFlowSelectColumnIotCardNo SimCardFlowSelectColumn = "iot_card_no"
	// column name
	SimCardFlowSelectColumnIsDelete SimCardFlowSelectColumn = "is_delete"
	// column name
	SimCardFlowSelectColumnIsSharePool SimCardFlowSelectColumn = "is_share_pool"
	// column name
	SimCardFlowSelectColumnPoolAvgFlow SimCardFlowSelectColumn = "pool_avg_flow"
	// column name
	SimCardFlowSelectColumnSimCardFlowID SimCardFlowSelectColumn = "sim_card_flow_id"
	// column name
	SimCardFlowSelectColumnSuitFlow SimCardFlowSelectColumn = "suit_flow"
	// column name
	SimCardFlowSelectColumnSuitLeftFlow SimCardFlowSelectColumn = "suit_left_flow"
	// column name
	SimCardFlowSelectColumnSuitOverFlow SimCardFlowSelectColumn = "suit_over_flow"
	// column name
	SimCardFlowSelectColumnSuitSmsLeftNum SimCardFlowSelectColumn = "suit_sms_left_num"
	// column name
	SimCardFlowSelectColumnSuitSmsNum SimCardFlowSelectColumn = "suit_sms_num"
	// column name
	SimCardFlowSelectColumnSuitSmsOverNum SimCardFlowSelectColumn = "suit_sms_over_num"
	// column name
	SimCardFlowSelectColumnSuitUseSmsNum SimCardFlowSelectColumn = "suit_use_sms_num"
	// column name
	SimCardFlowSelectColumnUpdateAt SimCardFlowSelectColumn = "update_at"
	// column name
	SimCardFlowSelectColumnUpdateBy SimCardFlowSelectColumn = "update_by"
	// column name
	SimCardFlowSelectColumnUseFlow SimCardFlowSelectColumn = "use_flow"
)

var AllSimCardFlowSelectColumn = []SimCardFlowSelectColumn{
	SimCardFlowSelectColumnCardAvgFlow,
	SimCardFlowSelectColumnCardNoRemark,
	SimCardFlowSelectColumnCreateAt,
	SimCardFlowSelectColumnCreateBy,
	SimCardFlowSelectColumnDeleteAt,
	SimCardFlowSelectColumnDeleteBy,
	SimCardFlowSelectColumnEnterpriseID,
	SimCardFlowSelectColumnIccid,
	SimCardFlowSelectColumnID,
	SimCardFlowSelectColumnIotCardNo,
	SimCardFlowSelectColumnIsDelete,
	SimCardFlowSelectColumnIsSharePool,
	SimCardFlowSelectColumnPoolAvgFlow,
	SimCardFlowSelectColumnSimCardFlowID,
	SimCardFlowSelectColumnSuitFlow,
	SimCardFlowSelectColumnSuitLeftFlow,
	SimCardFlowSelectColumnSuitOverFlow,
	SimCardFlowSelectColumnSuitSmsLeftNum,
	SimCardFlowSelectColumnSuitSmsNum,
	SimCardFlowSelectColumnSuitSmsOverNum,
	SimCardFlowSelectColumnSuitUseSmsNum,
	SimCardFlowSelectColumnUpdateAt,
	SimCardFlowSelectColumnUpdateBy,
	SimCardFlowSelectColumnUseFlow,
}

func (e SimCardFlowSelectColumn) IsValid() bool {
	switch e {
	case SimCardFlowSelectColumnCardAvgFlow, SimCardFlowSelectColumnCardNoRemark, SimCardFlowSelectColumnCreateAt, SimCardFlowSelectColumnCreateBy, SimCardFlowSelectColumnDeleteAt, SimCardFlowSelectColumnDeleteBy, SimCardFlowSelectColumnEnterpriseID, SimCardFlowSelectColumnIccid, SimCardFlowSelectColumnID, SimCardFlowSelectColumnIotCardNo, SimCardFlowSelectColumnIsDelete, SimCardFlowSelectColumnIsSharePool, SimCardFlowSelectColumnPoolAvgFlow, SimCardFlowSelectColumnSimCardFlowID, SimCardFlowSelectColumnSuitFlow, SimCardFlowSelectColumnSuitLeftFlow, SimCardFlowSelectColumnSuitOverFlow, SimCardFlowSelectColumnSuitSmsLeftNum, SimCardFlowSelectColumnSuitSmsNum, SimCardFlowSelectColumnSuitSmsOverNum, SimCardFlowSelectColumnSuitUseSmsNum, SimCardFlowSelectColumnUpdateAt, SimCardFlowSelectColumnUpdateBy, SimCardFlowSelectColumnUseFlow:
		return true
	}
	return false
}

func (e SimCardFlowSelectColumn) String() string {
	return string(e)
}

func (e *SimCardFlowSelectColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SimCardFlowSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid sim_card_flow_select_column", str)
	}
	return nil
}

func (e SimCardFlowSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// update columns of table "sim_card_flow"
type SimCardFlowUpdateColumn string

const (
	// column name
	SimCardFlowUpdateColumnCardAvgFlow SimCardFlowUpdateColumn = "card_avg_flow"
	// column name
	SimCardFlowUpdateColumnCardNoRemark SimCardFlowUpdateColumn = "card_no_remark"
	// column name
	SimCardFlowUpdateColumnCreateAt SimCardFlowUpdateColumn = "create_at"
	// column name
	SimCardFlowUpdateColumnCreateBy SimCardFlowUpdateColumn = "create_by"
	// column name
	SimCardFlowUpdateColumnDeleteAt SimCardFlowUpdateColumn = "delete_at"
	// column name
	SimCardFlowUpdateColumnDeleteBy SimCardFlowUpdateColumn = "delete_by"
	// column name
	SimCardFlowUpdateColumnEnterpriseID SimCardFlowUpdateColumn = "enterprise_id"
	// column name
	SimCardFlowUpdateColumnIccid SimCardFlowUpdateColumn = "iccid"
	// column name
	SimCardFlowUpdateColumnID SimCardFlowUpdateColumn = "id"
	// column name
	SimCardFlowUpdateColumnIotCardNo SimCardFlowUpdateColumn = "iot_card_no"
	// column name
	SimCardFlowUpdateColumnIsDelete SimCardFlowUpdateColumn = "is_delete"
	// column name
	SimCardFlowUpdateColumnIsSharePool SimCardFlowUpdateColumn = "is_share_pool"
	// column name
	SimCardFlowUpdateColumnPoolAvgFlow SimCardFlowUpdateColumn = "pool_avg_flow"
	// column name
	SimCardFlowUpdateColumnSimCardFlowID SimCardFlowUpdateColumn = "sim_card_flow_id"
	// column name
	SimCardFlowUpdateColumnSuitFlow SimCardFlowUpdateColumn = "suit_flow"
	// column name
	SimCardFlowUpdateColumnSuitLeftFlow SimCardFlowUpdateColumn = "suit_left_flow"
	// column name
	SimCardFlowUpdateColumnSuitOverFlow SimCardFlowUpdateColumn = "suit_over_flow"
	// column name
	SimCardFlowUpdateColumnSuitSmsLeftNum SimCardFlowUpdateColumn = "suit_sms_left_num"
	// column name
	SimCardFlowUpdateColumnSuitSmsNum SimCardFlowUpdateColumn = "suit_sms_num"
	// column name
	SimCardFlowUpdateColumnSuitSmsOverNum SimCardFlowUpdateColumn = "suit_sms_over_num"
	// column name
	SimCardFlowUpdateColumnSuitUseSmsNum SimCardFlowUpdateColumn = "suit_use_sms_num"
	// column name
	SimCardFlowUpdateColumnUpdateAt SimCardFlowUpdateColumn = "update_at"
	// column name
	SimCardFlowUpdateColumnUpdateBy SimCardFlowUpdateColumn = "update_by"
	// column name
	SimCardFlowUpdateColumnUseFlow SimCardFlowUpdateColumn = "use_flow"
)

var AllSimCardFlowUpdateColumn = []SimCardFlowUpdateColumn{
	SimCardFlowUpdateColumnCardAvgFlow,
	SimCardFlowUpdateColumnCardNoRemark,
	SimCardFlowUpdateColumnCreateAt,
	SimCardFlowUpdateColumnCreateBy,
	SimCardFlowUpdateColumnDeleteAt,
	SimCardFlowUpdateColumnDeleteBy,
	SimCardFlowUpdateColumnEnterpriseID,
	SimCardFlowUpdateColumnIccid,
	SimCardFlowUpdateColumnID,
	SimCardFlowUpdateColumnIotCardNo,
	SimCardFlowUpdateColumnIsDelete,
	SimCardFlowUpdateColumnIsSharePool,
	SimCardFlowUpdateColumnPoolAvgFlow,
	SimCardFlowUpdateColumnSimCardFlowID,
	SimCardFlowUpdateColumnSuitFlow,
	SimCardFlowUpdateColumnSuitLeftFlow,
	SimCardFlowUpdateColumnSuitOverFlow,
	SimCardFlowUpdateColumnSuitSmsLeftNum,
	SimCardFlowUpdateColumnSuitSmsNum,
	SimCardFlowUpdateColumnSuitSmsOverNum,
	SimCardFlowUpdateColumnSuitUseSmsNum,
	SimCardFlowUpdateColumnUpdateAt,
	SimCardFlowUpdateColumnUpdateBy,
	SimCardFlowUpdateColumnUseFlow,
}

func (e SimCardFlowUpdateColumn) IsValid() bool {
	switch e {
	case SimCardFlowUpdateColumnCardAvgFlow, SimCardFlowUpdateColumnCardNoRemark, SimCardFlowUpdateColumnCreateAt, SimCardFlowUpdateColumnCreateBy, SimCardFlowUpdateColumnDeleteAt, SimCardFlowUpdateColumnDeleteBy, SimCardFlowUpdateColumnEnterpriseID, SimCardFlowUpdateColumnIccid, SimCardFlowUpdateColumnID, SimCardFlowUpdateColumnIotCardNo, SimCardFlowUpdateColumnIsDelete, SimCardFlowUpdateColumnIsSharePool, SimCardFlowUpdateColumnPoolAvgFlow, SimCardFlowUpdateColumnSimCardFlowID, SimCardFlowUpdateColumnSuitFlow, SimCardFlowUpdateColumnSuitLeftFlow, SimCardFlowUpdateColumnSuitOverFlow, SimCardFlowUpdateColumnSuitSmsLeftNum, SimCardFlowUpdateColumnSuitSmsNum, SimCardFlowUpdateColumnSuitSmsOverNum, SimCardFlowUpdateColumnSuitUseSmsNum, SimCardFlowUpdateColumnUpdateAt, SimCardFlowUpdateColumnUpdateBy, SimCardFlowUpdateColumnUseFlow:
		return true
	}
	return false
}

func (e SimCardFlowUpdateColumn) String() string {
	return string(e)
}

func (e *SimCardFlowUpdateColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SimCardFlowUpdateColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid sim_card_flow_update_column", str)
	}
	return nil
}

func (e SimCardFlowUpdateColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// select columns of table "sim_card"
type SimCardSelectColumn string

const (
	// column name
	SimCardSelectColumnCreateAt SimCardSelectColumn = "create_at"
	// column name
	SimCardSelectColumnCreateBy SimCardSelectColumn = "create_by"
	// column name
	SimCardSelectColumnDeleteAt SimCardSelectColumn = "delete_at"
	// column name
	SimCardSelectColumnDeleteBy SimCardSelectColumn = "delete_by"
	// column name
	SimCardSelectColumnDeptID SimCardSelectColumn = "dept_id"
	// column name
	SimCardSelectColumnID SimCardSelectColumn = "id"
	// column name
	SimCardSelectColumnIsDelete SimCardSelectColumn = "is_delete"
	// column name
	SimCardSelectColumnMobileType SimCardSelectColumn = "mobile_type"
	// column name
	SimCardSelectColumnOperatorsID SimCardSelectColumn = "operators_id"
	// column name
	SimCardSelectColumnProxyrgID SimCardSelectColumn = "proxyrg_id"
	// column name
	SimCardSelectColumnRemark SimCardSelectColumn = "remark"
	// column name
	SimCardSelectColumnSimCardID SimCardSelectColumn = "sim_card_id"
	// column name
	SimCardSelectColumnSimNumber SimCardSelectColumn = "sim_number"
	// column name
	SimCardSelectColumnTerminalID SimCardSelectColumn = "terminal_id"
	// column name
	SimCardSelectColumnUpdateAt SimCardSelectColumn = "update_at"
	// column name
	SimCardSelectColumnUpdateBy SimCardSelectColumn = "update_by"
)

var AllSimCardSelectColumn = []SimCardSelectColumn{
	SimCardSelectColumnCreateAt,
	SimCardSelectColumnCreateBy,
	SimCardSelectColumnDeleteAt,
	SimCardSelectColumnDeleteBy,
	SimCardSelectColumnDeptID,
	SimCardSelectColumnID,
	SimCardSelectColumnIsDelete,
	SimCardSelectColumnMobileType,
	SimCardSelectColumnOperatorsID,
	SimCardSelectColumnProxyrgID,
	SimCardSelectColumnRemark,
	SimCardSelectColumnSimCardID,
	SimCardSelectColumnSimNumber,
	SimCardSelectColumnTerminalID,
	SimCardSelectColumnUpdateAt,
	SimCardSelectColumnUpdateBy,
}

func (e SimCardSelectColumn) IsValid() bool {
	switch e {
	case SimCardSelectColumnCreateAt, SimCardSelectColumnCreateBy, SimCardSelectColumnDeleteAt, SimCardSelectColumnDeleteBy, SimCardSelectColumnDeptID, SimCardSelectColumnID, SimCardSelectColumnIsDelete, SimCardSelectColumnMobileType, SimCardSelectColumnOperatorsID, SimCardSelectColumnProxyrgID, SimCardSelectColumnRemark, SimCardSelectColumnSimCardID, SimCardSelectColumnSimNumber, SimCardSelectColumnTerminalID, SimCardSelectColumnUpdateAt, SimCardSelectColumnUpdateBy:
		return true
	}
	return false
}

func (e SimCardSelectColumn) String() string {
	return string(e)
}

func (e *SimCardSelectColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SimCardSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid sim_card_select_column", str)
	}
	return nil
}

func (e SimCardSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// update columns of table "sim_card"
type SimCardUpdateColumn string

const (
	// column name
	SimCardUpdateColumnCreateAt SimCardUpdateColumn = "create_at"
	// column name
	SimCardUpdateColumnCreateBy SimCardUpdateColumn = "create_by"
	// column name
	SimCardUpdateColumnDeleteAt SimCardUpdateColumn = "delete_at"
	// column name
	SimCardUpdateColumnDeleteBy SimCardUpdateColumn = "delete_by"
	// column name
	SimCardUpdateColumnDeptID SimCardUpdateColumn = "dept_id"
	// column name
	SimCardUpdateColumnID SimCardUpdateColumn = "id"
	// column name
	SimCardUpdateColumnIsDelete SimCardUpdateColumn = "is_delete"
	// column name
	SimCardUpdateColumnMobileType SimCardUpdateColumn = "mobile_type"
	// column name
	SimCardUpdateColumnOperatorsID SimCardUpdateColumn = "operators_id"
	// column name
	SimCardUpdateColumnProxyrgID SimCardUpdateColumn = "proxyrg_id"
	// column name
	SimCardUpdateColumnRemark SimCardUpdateColumn = "remark"
	// column name
	SimCardUpdateColumnSimCardID SimCardUpdateColumn = "sim_card_id"
	// column name
	SimCardUpdateColumnSimNumber SimCardUpdateColumn = "sim_number"
	// column name
	SimCardUpdateColumnTerminalID SimCardUpdateColumn = "terminal_id"
	// column name
	SimCardUpdateColumnUpdateAt SimCardUpdateColumn = "update_at"
	// column name
	SimCardUpdateColumnUpdateBy SimCardUpdateColumn = "update_by"
)

var AllSimCardUpdateColumn = []SimCardUpdateColumn{
	SimCardUpdateColumnCreateAt,
	SimCardUpdateColumnCreateBy,
	SimCardUpdateColumnDeleteAt,
	SimCardUpdateColumnDeleteBy,
	SimCardUpdateColumnDeptID,
	SimCardUpdateColumnID,
	SimCardUpdateColumnIsDelete,
	SimCardUpdateColumnMobileType,
	SimCardUpdateColumnOperatorsID,
	SimCardUpdateColumnProxyrgID,
	SimCardUpdateColumnRemark,
	SimCardUpdateColumnSimCardID,
	SimCardUpdateColumnSimNumber,
	SimCardUpdateColumnTerminalID,
	SimCardUpdateColumnUpdateAt,
	SimCardUpdateColumnUpdateBy,
}

func (e SimCardUpdateColumn) IsValid() bool {
	switch e {
	case SimCardUpdateColumnCreateAt, SimCardUpdateColumnCreateBy, SimCardUpdateColumnDeleteAt, SimCardUpdateColumnDeleteBy, SimCardUpdateColumnDeptID, SimCardUpdateColumnID, SimCardUpdateColumnIsDelete, SimCardUpdateColumnMobileType, SimCardUpdateColumnOperatorsID, SimCardUpdateColumnProxyrgID, SimCardUpdateColumnRemark, SimCardUpdateColumnSimCardID, SimCardUpdateColumnSimNumber, SimCardUpdateColumnTerminalID, SimCardUpdateColumnUpdateAt, SimCardUpdateColumnUpdateBy:
		return true
	}
	return false
}

func (e SimCardUpdateColumn) String() string {
	return string(e)
}

func (e *SimCardUpdateColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SimCardUpdateColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid sim_card_update_column", str)
	}
	return nil
}

func (e SimCardUpdateColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// unique or primary key constraints on table "terminal"
type TerminalConstraint string

const (
	// unique or primary key constraint
	TerminalConstraintTerminalPkey TerminalConstraint = "terminal_pkey"
)

var AllTerminalConstraint = []TerminalConstraint{
	TerminalConstraintTerminalPkey,
}

func (e TerminalConstraint) IsValid() bool {
	switch e {
	case TerminalConstraintTerminalPkey:
		return true
	}
	return false
}

func (e TerminalConstraint) String() string {
	return string(e)
}

func (e *TerminalConstraint) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TerminalConstraint(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid terminal_constraint", str)
	}
	return nil
}

func (e TerminalConstraint) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// unique or primary key constraints on table "terminal_factory"
type TerminalFactoryConstraint string

const (
	// unique or primary key constraint
	TerminalFactoryConstraintTerminalFactoryPkey TerminalFactoryConstraint = "terminal_factory_pkey"
)

var AllTerminalFactoryConstraint = []TerminalFactoryConstraint{
	TerminalFactoryConstraintTerminalFactoryPkey,
}

func (e TerminalFactoryConstraint) IsValid() bool {
	switch e {
	case TerminalFactoryConstraintTerminalFactoryPkey:
		return true
	}
	return false
}

func (e TerminalFactoryConstraint) String() string {
	return string(e)
}

func (e *TerminalFactoryConstraint) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TerminalFactoryConstraint(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid terminal_factory_constraint", str)
	}
	return nil
}

func (e TerminalFactoryConstraint) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// select columns of table "terminal_factory"
type TerminalFactorySelectColumn string

const (
	// column name
	TerminalFactorySelectColumnAddress TerminalFactorySelectColumn = "address"
	// column name
	TerminalFactorySelectColumnContact TerminalFactorySelectColumn = "contact"
	// column name
	TerminalFactorySelectColumnContactPhone TerminalFactorySelectColumn = "contact_phone"
	// column name
	TerminalFactorySelectColumnCreateAt TerminalFactorySelectColumn = "create_at"
	// column name
	TerminalFactorySelectColumnCreateBy TerminalFactorySelectColumn = "create_by"
	// column name
	TerminalFactorySelectColumnDeleteAt TerminalFactorySelectColumn = "delete_at"
	// column name
	TerminalFactorySelectColumnDeleteBy TerminalFactorySelectColumn = "delete_by"
	// column name
	TerminalFactorySelectColumnFactoryID TerminalFactorySelectColumn = "factory_id"
	// column name
	TerminalFactorySelectColumnFactoryName TerminalFactorySelectColumn = "factory_name"
	// column name
	TerminalFactorySelectColumnID TerminalFactorySelectColumn = "id"
	// column name
	TerminalFactorySelectColumnIsDelete TerminalFactorySelectColumn = "is_delete"
	// column name
	TerminalFactorySelectColumnRemark TerminalFactorySelectColumn = "remark"
	// column name
	TerminalFactorySelectColumnTechContact TerminalFactorySelectColumn = "tech_contact"
	// column name
	TerminalFactorySelectColumnTechContactPhone TerminalFactorySelectColumn = "tech_contact_phone"
	// column name
	TerminalFactorySelectColumnUpdateAt TerminalFactorySelectColumn = "update_at"
	// column name
	TerminalFactorySelectColumnUpdateBy TerminalFactorySelectColumn = "update_by"
)

var AllTerminalFactorySelectColumn = []TerminalFactorySelectColumn{
	TerminalFactorySelectColumnAddress,
	TerminalFactorySelectColumnContact,
	TerminalFactorySelectColumnContactPhone,
	TerminalFactorySelectColumnCreateAt,
	TerminalFactorySelectColumnCreateBy,
	TerminalFactorySelectColumnDeleteAt,
	TerminalFactorySelectColumnDeleteBy,
	TerminalFactorySelectColumnFactoryID,
	TerminalFactorySelectColumnFactoryName,
	TerminalFactorySelectColumnID,
	TerminalFactorySelectColumnIsDelete,
	TerminalFactorySelectColumnRemark,
	TerminalFactorySelectColumnTechContact,
	TerminalFactorySelectColumnTechContactPhone,
	TerminalFactorySelectColumnUpdateAt,
	TerminalFactorySelectColumnUpdateBy,
}

func (e TerminalFactorySelectColumn) IsValid() bool {
	switch e {
	case TerminalFactorySelectColumnAddress, TerminalFactorySelectColumnContact, TerminalFactorySelectColumnContactPhone, TerminalFactorySelectColumnCreateAt, TerminalFactorySelectColumnCreateBy, TerminalFactorySelectColumnDeleteAt, TerminalFactorySelectColumnDeleteBy, TerminalFactorySelectColumnFactoryID, TerminalFactorySelectColumnFactoryName, TerminalFactorySelectColumnID, TerminalFactorySelectColumnIsDelete, TerminalFactorySelectColumnRemark, TerminalFactorySelectColumnTechContact, TerminalFactorySelectColumnTechContactPhone, TerminalFactorySelectColumnUpdateAt, TerminalFactorySelectColumnUpdateBy:
		return true
	}
	return false
}

func (e TerminalFactorySelectColumn) String() string {
	return string(e)
}

func (e *TerminalFactorySelectColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TerminalFactorySelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid terminal_factory_select_column", str)
	}
	return nil
}

func (e TerminalFactorySelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// update columns of table "terminal_factory"
type TerminalFactoryUpdateColumn string

const (
	// column name
	TerminalFactoryUpdateColumnAddress TerminalFactoryUpdateColumn = "address"
	// column name
	TerminalFactoryUpdateColumnContact TerminalFactoryUpdateColumn = "contact"
	// column name
	TerminalFactoryUpdateColumnContactPhone TerminalFactoryUpdateColumn = "contact_phone"
	// column name
	TerminalFactoryUpdateColumnCreateAt TerminalFactoryUpdateColumn = "create_at"
	// column name
	TerminalFactoryUpdateColumnCreateBy TerminalFactoryUpdateColumn = "create_by"
	// column name
	TerminalFactoryUpdateColumnDeleteAt TerminalFactoryUpdateColumn = "delete_at"
	// column name
	TerminalFactoryUpdateColumnDeleteBy TerminalFactoryUpdateColumn = "delete_by"
	// column name
	TerminalFactoryUpdateColumnFactoryID TerminalFactoryUpdateColumn = "factory_id"
	// column name
	TerminalFactoryUpdateColumnFactoryName TerminalFactoryUpdateColumn = "factory_name"
	// column name
	TerminalFactoryUpdateColumnID TerminalFactoryUpdateColumn = "id"
	// column name
	TerminalFactoryUpdateColumnIsDelete TerminalFactoryUpdateColumn = "is_delete"
	// column name
	TerminalFactoryUpdateColumnRemark TerminalFactoryUpdateColumn = "remark"
	// column name
	TerminalFactoryUpdateColumnTechContact TerminalFactoryUpdateColumn = "tech_contact"
	// column name
	TerminalFactoryUpdateColumnTechContactPhone TerminalFactoryUpdateColumn = "tech_contact_phone"
	// column name
	TerminalFactoryUpdateColumnUpdateAt TerminalFactoryUpdateColumn = "update_at"
	// column name
	TerminalFactoryUpdateColumnUpdateBy TerminalFactoryUpdateColumn = "update_by"
)

var AllTerminalFactoryUpdateColumn = []TerminalFactoryUpdateColumn{
	TerminalFactoryUpdateColumnAddress,
	TerminalFactoryUpdateColumnContact,
	TerminalFactoryUpdateColumnContactPhone,
	TerminalFactoryUpdateColumnCreateAt,
	TerminalFactoryUpdateColumnCreateBy,
	TerminalFactoryUpdateColumnDeleteAt,
	TerminalFactoryUpdateColumnDeleteBy,
	TerminalFactoryUpdateColumnFactoryID,
	TerminalFactoryUpdateColumnFactoryName,
	TerminalFactoryUpdateColumnID,
	TerminalFactoryUpdateColumnIsDelete,
	TerminalFactoryUpdateColumnRemark,
	TerminalFactoryUpdateColumnTechContact,
	TerminalFactoryUpdateColumnTechContactPhone,
	TerminalFactoryUpdateColumnUpdateAt,
	TerminalFactoryUpdateColumnUpdateBy,
}

func (e TerminalFactoryUpdateColumn) IsValid() bool {
	switch e {
	case TerminalFactoryUpdateColumnAddress, TerminalFactoryUpdateColumnContact, TerminalFactoryUpdateColumnContactPhone, TerminalFactoryUpdateColumnCreateAt, TerminalFactoryUpdateColumnCreateBy, TerminalFactoryUpdateColumnDeleteAt, TerminalFactoryUpdateColumnDeleteBy, TerminalFactoryUpdateColumnFactoryID, TerminalFactoryUpdateColumnFactoryName, TerminalFactoryUpdateColumnID, TerminalFactoryUpdateColumnIsDelete, TerminalFactoryUpdateColumnRemark, TerminalFactoryUpdateColumnTechContact, TerminalFactoryUpdateColumnTechContactPhone, TerminalFactoryUpdateColumnUpdateAt, TerminalFactoryUpdateColumnUpdateBy:
		return true
	}
	return false
}

func (e TerminalFactoryUpdateColumn) String() string {
	return string(e)
}

func (e *TerminalFactoryUpdateColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TerminalFactoryUpdateColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid terminal_factory_update_column", str)
	}
	return nil
}

func (e TerminalFactoryUpdateColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// unique or primary key constraints on table "terminal_modal"
type TerminalModalConstraint string

const (
	// unique or primary key constraint
	TerminalModalConstraintTerminalModalPkey TerminalModalConstraint = "terminal_modal_pkey"
)

var AllTerminalModalConstraint = []TerminalModalConstraint{
	TerminalModalConstraintTerminalModalPkey,
}

func (e TerminalModalConstraint) IsValid() bool {
	switch e {
	case TerminalModalConstraintTerminalModalPkey:
		return true
	}
	return false
}

func (e TerminalModalConstraint) String() string {
	return string(e)
}

func (e *TerminalModalConstraint) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TerminalModalConstraint(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid terminal_modal_constraint", str)
	}
	return nil
}

func (e TerminalModalConstraint) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// select columns of table "terminal_modal"
type TerminalModalSelectColumn string

const (
	// column name
	TerminalModalSelectColumnAdasModal TerminalModalSelectColumn = "adas_modal"
	// column name
	TerminalModalSelectColumnCreateAt TerminalModalSelectColumn = "create_at"
	// column name
	TerminalModalSelectColumnCreateBy TerminalModalSelectColumn = "create_by"
	// column name
	TerminalModalSelectColumnDeleteAt TerminalModalSelectColumn = "delete_at"
	// column name
	TerminalModalSelectColumnDeleteBy TerminalModalSelectColumn = "delete_by"
	// column name
	TerminalModalSelectColumnFactoryID TerminalModalSelectColumn = "factory_id"
	// column name
	TerminalModalSelectColumnID TerminalModalSelectColumn = "id"
	// column name
	TerminalModalSelectColumnIsDelete TerminalModalSelectColumn = "is_delete"
	// column name
	TerminalModalSelectColumnIsElectronicsPostCard TerminalModalSelectColumn = "is_electronics_post_card"
	// column name
	TerminalModalSelectColumnIsSlagCarTeminal TerminalModalSelectColumn = "is_slag_car_teminal"
	// column name
	TerminalModalSelectColumnIsTestingSituation TerminalModalSelectColumn = "is_testing_situation"
	// column name
	TerminalModalSelectColumnIsTransportDept4g TerminalModalSelectColumn = "is_transport_dept_4g"
	// column name
	TerminalModalSelectColumnModalName TerminalModalSelectColumn = "modal_name"
	// column name
	TerminalModalSelectColumnProxyrgID TerminalModalSelectColumn = "proxyrg_id"
	// column name
	TerminalModalSelectColumnRecordNo TerminalModalSelectColumn = "record_no"
	// column name
	TerminalModalSelectColumnRemark TerminalModalSelectColumn = "remark"
	// column name
	TerminalModalSelectColumnTerminalModalID TerminalModalSelectColumn = "terminal_modal_id"
	// column name
	TerminalModalSelectColumnTerminalTypeID TerminalModalSelectColumn = "terminal_type_id"
	// column name
	TerminalModalSelectColumnUpdateAt TerminalModalSelectColumn = "update_at"
	// column name
	TerminalModalSelectColumnUpdateBy TerminalModalSelectColumn = "update_by"
)

var AllTerminalModalSelectColumn = []TerminalModalSelectColumn{
	TerminalModalSelectColumnAdasModal,
	TerminalModalSelectColumnCreateAt,
	TerminalModalSelectColumnCreateBy,
	TerminalModalSelectColumnDeleteAt,
	TerminalModalSelectColumnDeleteBy,
	TerminalModalSelectColumnFactoryID,
	TerminalModalSelectColumnID,
	TerminalModalSelectColumnIsDelete,
	TerminalModalSelectColumnIsElectronicsPostCard,
	TerminalModalSelectColumnIsSlagCarTeminal,
	TerminalModalSelectColumnIsTestingSituation,
	TerminalModalSelectColumnIsTransportDept4g,
	TerminalModalSelectColumnModalName,
	TerminalModalSelectColumnProxyrgID,
	TerminalModalSelectColumnRecordNo,
	TerminalModalSelectColumnRemark,
	TerminalModalSelectColumnTerminalModalID,
	TerminalModalSelectColumnTerminalTypeID,
	TerminalModalSelectColumnUpdateAt,
	TerminalModalSelectColumnUpdateBy,
}

func (e TerminalModalSelectColumn) IsValid() bool {
	switch e {
	case TerminalModalSelectColumnAdasModal, TerminalModalSelectColumnCreateAt, TerminalModalSelectColumnCreateBy, TerminalModalSelectColumnDeleteAt, TerminalModalSelectColumnDeleteBy, TerminalModalSelectColumnFactoryID, TerminalModalSelectColumnID, TerminalModalSelectColumnIsDelete, TerminalModalSelectColumnIsElectronicsPostCard, TerminalModalSelectColumnIsSlagCarTeminal, TerminalModalSelectColumnIsTestingSituation, TerminalModalSelectColumnIsTransportDept4g, TerminalModalSelectColumnModalName, TerminalModalSelectColumnProxyrgID, TerminalModalSelectColumnRecordNo, TerminalModalSelectColumnRemark, TerminalModalSelectColumnTerminalModalID, TerminalModalSelectColumnTerminalTypeID, TerminalModalSelectColumnUpdateAt, TerminalModalSelectColumnUpdateBy:
		return true
	}
	return false
}

func (e TerminalModalSelectColumn) String() string {
	return string(e)
}

func (e *TerminalModalSelectColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TerminalModalSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid terminal_modal_select_column", str)
	}
	return nil
}

func (e TerminalModalSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// update columns of table "terminal_modal"
type TerminalModalUpdateColumn string

const (
	// column name
	TerminalModalUpdateColumnAdasModal TerminalModalUpdateColumn = "adas_modal"
	// column name
	TerminalModalUpdateColumnCreateAt TerminalModalUpdateColumn = "create_at"
	// column name
	TerminalModalUpdateColumnCreateBy TerminalModalUpdateColumn = "create_by"
	// column name
	TerminalModalUpdateColumnDeleteAt TerminalModalUpdateColumn = "delete_at"
	// column name
	TerminalModalUpdateColumnDeleteBy TerminalModalUpdateColumn = "delete_by"
	// column name
	TerminalModalUpdateColumnFactoryID TerminalModalUpdateColumn = "factory_id"
	// column name
	TerminalModalUpdateColumnID TerminalModalUpdateColumn = "id"
	// column name
	TerminalModalUpdateColumnIsDelete TerminalModalUpdateColumn = "is_delete"
	// column name
	TerminalModalUpdateColumnIsElectronicsPostCard TerminalModalUpdateColumn = "is_electronics_post_card"
	// column name
	TerminalModalUpdateColumnIsSlagCarTeminal TerminalModalUpdateColumn = "is_slag_car_teminal"
	// column name
	TerminalModalUpdateColumnIsTestingSituation TerminalModalUpdateColumn = "is_testing_situation"
	// column name
	TerminalModalUpdateColumnIsTransportDept4g TerminalModalUpdateColumn = "is_transport_dept_4g"
	// column name
	TerminalModalUpdateColumnModalName TerminalModalUpdateColumn = "modal_name"
	// column name
	TerminalModalUpdateColumnProxyrgID TerminalModalUpdateColumn = "proxyrg_id"
	// column name
	TerminalModalUpdateColumnRecordNo TerminalModalUpdateColumn = "record_no"
	// column name
	TerminalModalUpdateColumnRemark TerminalModalUpdateColumn = "remark"
	// column name
	TerminalModalUpdateColumnTerminalModalID TerminalModalUpdateColumn = "terminal_modal_id"
	// column name
	TerminalModalUpdateColumnTerminalTypeID TerminalModalUpdateColumn = "terminal_type_id"
	// column name
	TerminalModalUpdateColumnUpdateAt TerminalModalUpdateColumn = "update_at"
	// column name
	TerminalModalUpdateColumnUpdateBy TerminalModalUpdateColumn = "update_by"
)

var AllTerminalModalUpdateColumn = []TerminalModalUpdateColumn{
	TerminalModalUpdateColumnAdasModal,
	TerminalModalUpdateColumnCreateAt,
	TerminalModalUpdateColumnCreateBy,
	TerminalModalUpdateColumnDeleteAt,
	TerminalModalUpdateColumnDeleteBy,
	TerminalModalUpdateColumnFactoryID,
	TerminalModalUpdateColumnID,
	TerminalModalUpdateColumnIsDelete,
	TerminalModalUpdateColumnIsElectronicsPostCard,
	TerminalModalUpdateColumnIsSlagCarTeminal,
	TerminalModalUpdateColumnIsTestingSituation,
	TerminalModalUpdateColumnIsTransportDept4g,
	TerminalModalUpdateColumnModalName,
	TerminalModalUpdateColumnProxyrgID,
	TerminalModalUpdateColumnRecordNo,
	TerminalModalUpdateColumnRemark,
	TerminalModalUpdateColumnTerminalModalID,
	TerminalModalUpdateColumnTerminalTypeID,
	TerminalModalUpdateColumnUpdateAt,
	TerminalModalUpdateColumnUpdateBy,
}

func (e TerminalModalUpdateColumn) IsValid() bool {
	switch e {
	case TerminalModalUpdateColumnAdasModal, TerminalModalUpdateColumnCreateAt, TerminalModalUpdateColumnCreateBy, TerminalModalUpdateColumnDeleteAt, TerminalModalUpdateColumnDeleteBy, TerminalModalUpdateColumnFactoryID, TerminalModalUpdateColumnID, TerminalModalUpdateColumnIsDelete, TerminalModalUpdateColumnIsElectronicsPostCard, TerminalModalUpdateColumnIsSlagCarTeminal, TerminalModalUpdateColumnIsTestingSituation, TerminalModalUpdateColumnIsTransportDept4g, TerminalModalUpdateColumnModalName, TerminalModalUpdateColumnProxyrgID, TerminalModalUpdateColumnRecordNo, TerminalModalUpdateColumnRemark, TerminalModalUpdateColumnTerminalModalID, TerminalModalUpdateColumnTerminalTypeID, TerminalModalUpdateColumnUpdateAt, TerminalModalUpdateColumnUpdateBy:
		return true
	}
	return false
}

func (e TerminalModalUpdateColumn) String() string {
	return string(e)
}

func (e *TerminalModalUpdateColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TerminalModalUpdateColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid terminal_modal_update_column", str)
	}
	return nil
}

func (e TerminalModalUpdateColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// select columns of table "terminal"
type TerminalSelectColumn string

const (
	// column name
	TerminalSelectColumnAdasModel TerminalSelectColumn = "adas_model"
	// column name
	TerminalSelectColumnAuthKey TerminalSelectColumn = "auth_key"
	// column name
	TerminalSelectColumnCameraNum TerminalSelectColumn = "camera_num"
	// column name
	TerminalSelectColumnChannelNo TerminalSelectColumn = "channel_no"
	// column name
	TerminalSelectColumnCityID TerminalSelectColumn = "city_id"
	// column name
	TerminalSelectColumnCreateAt TerminalSelectColumn = "create_at"
	// column name
	TerminalSelectColumnCreateBy TerminalSelectColumn = "create_by"
	// column name
	TerminalSelectColumnDeleteAt TerminalSelectColumn = "delete_at"
	// column name
	TerminalSelectColumnDeleteBy TerminalSelectColumn = "delete_by"
	// column name
	TerminalSelectColumnDeptID TerminalSelectColumn = "dept_id"
	// column name
	TerminalSelectColumnFirstInstallTime TerminalSelectColumn = "first_install_time"
	// column name
	TerminalSelectColumnGuaranteeDate TerminalSelectColumn = "guarantee_date"
	// column name
	TerminalSelectColumnID TerminalSelectColumn = "id"
	// column name
	TerminalSelectColumnImei TerminalSelectColumn = "imei"
	// column name
	TerminalSelectColumnInstallManID TerminalSelectColumn = "install_man_id"
	// column name
	TerminalSelectColumnIsDelete TerminalSelectColumn = "is_delete"
	// column name
	TerminalSelectColumnIsReg TerminalSelectColumn = "is_reg"
	// column name
	TerminalSelectColumnIsSupportPhoto TerminalSelectColumn = "is_support_photo"
	// column name
	TerminalSelectColumnMockAuthKey TerminalSelectColumn = "mock_auth_key"
	// column name
	TerminalSelectColumnProduceDate TerminalSelectColumn = "produce_date"
	// column name
	TerminalSelectColumnProveProxyrgID TerminalSelectColumn = "prove_proxyrg_id"
	// column name
	TerminalSelectColumnProvinceID TerminalSelectColumn = "province_id"
	// column name
	TerminalSelectColumnProxyrgID TerminalSelectColumn = "proxyrg_id"
	// column name
	TerminalSelectColumnRecordDate TerminalSelectColumn = "record_date"
	// column name
	TerminalSelectColumnRegID TerminalSelectColumn = "reg_id"
	// column name
	TerminalSelectColumnRemarks TerminalSelectColumn = "remarks"
	// column name
	TerminalSelectColumnRemoveReason TerminalSelectColumn = "remove_reason"
	// column name
	TerminalSelectColumnSimID TerminalSelectColumn = "sim_id"
	// column name
	TerminalSelectColumnSprgID TerminalSelectColumn = "sprg_id"
	// column name
	TerminalSelectColumnTerminalID TerminalSelectColumn = "terminal_id"
	// column name
	TerminalSelectColumnTypeID TerminalSelectColumn = "type_id"
	// column name
	TerminalSelectColumnUpdateAt TerminalSelectColumn = "update_at"
	// column name
	TerminalSelectColumnUpdateBy TerminalSelectColumn = "update_by"
	// column name
	TerminalSelectColumnVehicleID TerminalSelectColumn = "vehicle_id"
	// column name
	TerminalSelectColumnVersionNumber TerminalSelectColumn = "version_number"
)

var AllTerminalSelectColumn = []TerminalSelectColumn{
	TerminalSelectColumnAdasModel,
	TerminalSelectColumnAuthKey,
	TerminalSelectColumnCameraNum,
	TerminalSelectColumnChannelNo,
	TerminalSelectColumnCityID,
	TerminalSelectColumnCreateAt,
	TerminalSelectColumnCreateBy,
	TerminalSelectColumnDeleteAt,
	TerminalSelectColumnDeleteBy,
	TerminalSelectColumnDeptID,
	TerminalSelectColumnFirstInstallTime,
	TerminalSelectColumnGuaranteeDate,
	TerminalSelectColumnID,
	TerminalSelectColumnImei,
	TerminalSelectColumnInstallManID,
	TerminalSelectColumnIsDelete,
	TerminalSelectColumnIsReg,
	TerminalSelectColumnIsSupportPhoto,
	TerminalSelectColumnMockAuthKey,
	TerminalSelectColumnProduceDate,
	TerminalSelectColumnProveProxyrgID,
	TerminalSelectColumnProvinceID,
	TerminalSelectColumnProxyrgID,
	TerminalSelectColumnRecordDate,
	TerminalSelectColumnRegID,
	TerminalSelectColumnRemarks,
	TerminalSelectColumnRemoveReason,
	TerminalSelectColumnSimID,
	TerminalSelectColumnSprgID,
	TerminalSelectColumnTerminalID,
	TerminalSelectColumnTypeID,
	TerminalSelectColumnUpdateAt,
	TerminalSelectColumnUpdateBy,
	TerminalSelectColumnVehicleID,
	TerminalSelectColumnVersionNumber,
}

func (e TerminalSelectColumn) IsValid() bool {
	switch e {
	case TerminalSelectColumnAdasModel, TerminalSelectColumnAuthKey, TerminalSelectColumnCameraNum, TerminalSelectColumnChannelNo, TerminalSelectColumnCityID, TerminalSelectColumnCreateAt, TerminalSelectColumnCreateBy, TerminalSelectColumnDeleteAt, TerminalSelectColumnDeleteBy, TerminalSelectColumnDeptID, TerminalSelectColumnFirstInstallTime, TerminalSelectColumnGuaranteeDate, TerminalSelectColumnID, TerminalSelectColumnImei, TerminalSelectColumnInstallManID, TerminalSelectColumnIsDelete, TerminalSelectColumnIsReg, TerminalSelectColumnIsSupportPhoto, TerminalSelectColumnMockAuthKey, TerminalSelectColumnProduceDate, TerminalSelectColumnProveProxyrgID, TerminalSelectColumnProvinceID, TerminalSelectColumnProxyrgID, TerminalSelectColumnRecordDate, TerminalSelectColumnRegID, TerminalSelectColumnRemarks, TerminalSelectColumnRemoveReason, TerminalSelectColumnSimID, TerminalSelectColumnSprgID, TerminalSelectColumnTerminalID, TerminalSelectColumnTypeID, TerminalSelectColumnUpdateAt, TerminalSelectColumnUpdateBy, TerminalSelectColumnVehicleID, TerminalSelectColumnVersionNumber:
		return true
	}
	return false
}

func (e TerminalSelectColumn) String() string {
	return string(e)
}

func (e *TerminalSelectColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TerminalSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid terminal_select_column", str)
	}
	return nil
}

func (e TerminalSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// unique or primary key constraints on table "terminal_types"
type TerminalTypesConstraint string

const (
	// unique or primary key constraint
	TerminalTypesConstraintTerminalTypePkey TerminalTypesConstraint = "terminal_type_pkey"
)

var AllTerminalTypesConstraint = []TerminalTypesConstraint{
	TerminalTypesConstraintTerminalTypePkey,
}

func (e TerminalTypesConstraint) IsValid() bool {
	switch e {
	case TerminalTypesConstraintTerminalTypePkey:
		return true
	}
	return false
}

func (e TerminalTypesConstraint) String() string {
	return string(e)
}

func (e *TerminalTypesConstraint) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TerminalTypesConstraint(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid terminal_types_constraint", str)
	}
	return nil
}

func (e TerminalTypesConstraint) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// select columns of table "terminal_types"
type TerminalTypesSelectColumn string

const (
	// column name
	TerminalTypesSelectColumnCreateAt TerminalTypesSelectColumn = "create_at"
	// column name
	TerminalTypesSelectColumnCreateBy TerminalTypesSelectColumn = "create_by"
	// column name
	TerminalTypesSelectColumnDeleteAt TerminalTypesSelectColumn = "delete_at"
	// column name
	TerminalTypesSelectColumnDeleteBy TerminalTypesSelectColumn = "delete_by"
	// column name
	TerminalTypesSelectColumnID TerminalTypesSelectColumn = "id"
	// column name
	TerminalTypesSelectColumnIsDelete TerminalTypesSelectColumn = "is_delete"
	// column name
	TerminalTypesSelectColumnProtocolName TerminalTypesSelectColumn = "protocol_name"
	// column name
	TerminalTypesSelectColumnRemark TerminalTypesSelectColumn = "remark"
	// column name
	TerminalTypesSelectColumnTypeID TerminalTypesSelectColumn = "type_id"
	// column name
	TerminalTypesSelectColumnUpdateAt TerminalTypesSelectColumn = "update_at"
	// column name
	TerminalTypesSelectColumnUpdateBy TerminalTypesSelectColumn = "update_by"
)

var AllTerminalTypesSelectColumn = []TerminalTypesSelectColumn{
	TerminalTypesSelectColumnCreateAt,
	TerminalTypesSelectColumnCreateBy,
	TerminalTypesSelectColumnDeleteAt,
	TerminalTypesSelectColumnDeleteBy,
	TerminalTypesSelectColumnID,
	TerminalTypesSelectColumnIsDelete,
	TerminalTypesSelectColumnProtocolName,
	TerminalTypesSelectColumnRemark,
	TerminalTypesSelectColumnTypeID,
	TerminalTypesSelectColumnUpdateAt,
	TerminalTypesSelectColumnUpdateBy,
}

func (e TerminalTypesSelectColumn) IsValid() bool {
	switch e {
	case TerminalTypesSelectColumnCreateAt, TerminalTypesSelectColumnCreateBy, TerminalTypesSelectColumnDeleteAt, TerminalTypesSelectColumnDeleteBy, TerminalTypesSelectColumnID, TerminalTypesSelectColumnIsDelete, TerminalTypesSelectColumnProtocolName, TerminalTypesSelectColumnRemark, TerminalTypesSelectColumnTypeID, TerminalTypesSelectColumnUpdateAt, TerminalTypesSelectColumnUpdateBy:
		return true
	}
	return false
}

func (e TerminalTypesSelectColumn) String() string {
	return string(e)
}

func (e *TerminalTypesSelectColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TerminalTypesSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid terminal_types_select_column", str)
	}
	return nil
}

func (e TerminalTypesSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// update columns of table "terminal_types"
type TerminalTypesUpdateColumn string

const (
	// column name
	TerminalTypesUpdateColumnCreateAt TerminalTypesUpdateColumn = "create_at"
	// column name
	TerminalTypesUpdateColumnCreateBy TerminalTypesUpdateColumn = "create_by"
	// column name
	TerminalTypesUpdateColumnDeleteAt TerminalTypesUpdateColumn = "delete_at"
	// column name
	TerminalTypesUpdateColumnDeleteBy TerminalTypesUpdateColumn = "delete_by"
	// column name
	TerminalTypesUpdateColumnID TerminalTypesUpdateColumn = "id"
	// column name
	TerminalTypesUpdateColumnIsDelete TerminalTypesUpdateColumn = "is_delete"
	// column name
	TerminalTypesUpdateColumnProtocolName TerminalTypesUpdateColumn = "protocol_name"
	// column name
	TerminalTypesUpdateColumnRemark TerminalTypesUpdateColumn = "remark"
	// column name
	TerminalTypesUpdateColumnTypeID TerminalTypesUpdateColumn = "type_id"
	// column name
	TerminalTypesUpdateColumnUpdateAt TerminalTypesUpdateColumn = "update_at"
	// column name
	TerminalTypesUpdateColumnUpdateBy TerminalTypesUpdateColumn = "update_by"
)

var AllTerminalTypesUpdateColumn = []TerminalTypesUpdateColumn{
	TerminalTypesUpdateColumnCreateAt,
	TerminalTypesUpdateColumnCreateBy,
	TerminalTypesUpdateColumnDeleteAt,
	TerminalTypesUpdateColumnDeleteBy,
	TerminalTypesUpdateColumnID,
	TerminalTypesUpdateColumnIsDelete,
	TerminalTypesUpdateColumnProtocolName,
	TerminalTypesUpdateColumnRemark,
	TerminalTypesUpdateColumnTypeID,
	TerminalTypesUpdateColumnUpdateAt,
	TerminalTypesUpdateColumnUpdateBy,
}

func (e TerminalTypesUpdateColumn) IsValid() bool {
	switch e {
	case TerminalTypesUpdateColumnCreateAt, TerminalTypesUpdateColumnCreateBy, TerminalTypesUpdateColumnDeleteAt, TerminalTypesUpdateColumnDeleteBy, TerminalTypesUpdateColumnID, TerminalTypesUpdateColumnIsDelete, TerminalTypesUpdateColumnProtocolName, TerminalTypesUpdateColumnRemark, TerminalTypesUpdateColumnTypeID, TerminalTypesUpdateColumnUpdateAt, TerminalTypesUpdateColumnUpdateBy:
		return true
	}
	return false
}

func (e TerminalTypesUpdateColumn) String() string {
	return string(e)
}

func (e *TerminalTypesUpdateColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TerminalTypesUpdateColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid terminal_types_update_column", str)
	}
	return nil
}

func (e TerminalTypesUpdateColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// update columns of table "terminal"
type TerminalUpdateColumn string

const (
	// column name
	TerminalUpdateColumnAdasModel TerminalUpdateColumn = "adas_model"
	// column name
	TerminalUpdateColumnAuthKey TerminalUpdateColumn = "auth_key"
	// column name
	TerminalUpdateColumnCameraNum TerminalUpdateColumn = "camera_num"
	// column name
	TerminalUpdateColumnChannelNo TerminalUpdateColumn = "channel_no"
	// column name
	TerminalUpdateColumnCityID TerminalUpdateColumn = "city_id"
	// column name
	TerminalUpdateColumnCreateAt TerminalUpdateColumn = "create_at"
	// column name
	TerminalUpdateColumnCreateBy TerminalUpdateColumn = "create_by"
	// column name
	TerminalUpdateColumnDeleteAt TerminalUpdateColumn = "delete_at"
	// column name
	TerminalUpdateColumnDeleteBy TerminalUpdateColumn = "delete_by"
	// column name
	TerminalUpdateColumnDeptID TerminalUpdateColumn = "dept_id"
	// column name
	TerminalUpdateColumnFirstInstallTime TerminalUpdateColumn = "first_install_time"
	// column name
	TerminalUpdateColumnGuaranteeDate TerminalUpdateColumn = "guarantee_date"
	// column name
	TerminalUpdateColumnID TerminalUpdateColumn = "id"
	// column name
	TerminalUpdateColumnImei TerminalUpdateColumn = "imei"
	// column name
	TerminalUpdateColumnInstallManID TerminalUpdateColumn = "install_man_id"
	// column name
	TerminalUpdateColumnIsDelete TerminalUpdateColumn = "is_delete"
	// column name
	TerminalUpdateColumnIsReg TerminalUpdateColumn = "is_reg"
	// column name
	TerminalUpdateColumnIsSupportPhoto TerminalUpdateColumn = "is_support_photo"
	// column name
	TerminalUpdateColumnMockAuthKey TerminalUpdateColumn = "mock_auth_key"
	// column name
	TerminalUpdateColumnProduceDate TerminalUpdateColumn = "produce_date"
	// column name
	TerminalUpdateColumnProveProxyrgID TerminalUpdateColumn = "prove_proxyrg_id"
	// column name
	TerminalUpdateColumnProvinceID TerminalUpdateColumn = "province_id"
	// column name
	TerminalUpdateColumnProxyrgID TerminalUpdateColumn = "proxyrg_id"
	// column name
	TerminalUpdateColumnRecordDate TerminalUpdateColumn = "record_date"
	// column name
	TerminalUpdateColumnRegID TerminalUpdateColumn = "reg_id"
	// column name
	TerminalUpdateColumnRemarks TerminalUpdateColumn = "remarks"
	// column name
	TerminalUpdateColumnRemoveReason TerminalUpdateColumn = "remove_reason"
	// column name
	TerminalUpdateColumnSimID TerminalUpdateColumn = "sim_id"
	// column name
	TerminalUpdateColumnSprgID TerminalUpdateColumn = "sprg_id"
	// column name
	TerminalUpdateColumnTerminalID TerminalUpdateColumn = "terminal_id"
	// column name
	TerminalUpdateColumnTypeID TerminalUpdateColumn = "type_id"
	// column name
	TerminalUpdateColumnUpdateAt TerminalUpdateColumn = "update_at"
	// column name
	TerminalUpdateColumnUpdateBy TerminalUpdateColumn = "update_by"
	// column name
	TerminalUpdateColumnVehicleID TerminalUpdateColumn = "vehicle_id"
	// column name
	TerminalUpdateColumnVersionNumber TerminalUpdateColumn = "version_number"
)

var AllTerminalUpdateColumn = []TerminalUpdateColumn{
	TerminalUpdateColumnAdasModel,
	TerminalUpdateColumnAuthKey,
	TerminalUpdateColumnCameraNum,
	TerminalUpdateColumnChannelNo,
	TerminalUpdateColumnCityID,
	TerminalUpdateColumnCreateAt,
	TerminalUpdateColumnCreateBy,
	TerminalUpdateColumnDeleteAt,
	TerminalUpdateColumnDeleteBy,
	TerminalUpdateColumnDeptID,
	TerminalUpdateColumnFirstInstallTime,
	TerminalUpdateColumnGuaranteeDate,
	TerminalUpdateColumnID,
	TerminalUpdateColumnImei,
	TerminalUpdateColumnInstallManID,
	TerminalUpdateColumnIsDelete,
	TerminalUpdateColumnIsReg,
	TerminalUpdateColumnIsSupportPhoto,
	TerminalUpdateColumnMockAuthKey,
	TerminalUpdateColumnProduceDate,
	TerminalUpdateColumnProveProxyrgID,
	TerminalUpdateColumnProvinceID,
	TerminalUpdateColumnProxyrgID,
	TerminalUpdateColumnRecordDate,
	TerminalUpdateColumnRegID,
	TerminalUpdateColumnRemarks,
	TerminalUpdateColumnRemoveReason,
	TerminalUpdateColumnSimID,
	TerminalUpdateColumnSprgID,
	TerminalUpdateColumnTerminalID,
	TerminalUpdateColumnTypeID,
	TerminalUpdateColumnUpdateAt,
	TerminalUpdateColumnUpdateBy,
	TerminalUpdateColumnVehicleID,
	TerminalUpdateColumnVersionNumber,
}

func (e TerminalUpdateColumn) IsValid() bool {
	switch e {
	case TerminalUpdateColumnAdasModel, TerminalUpdateColumnAuthKey, TerminalUpdateColumnCameraNum, TerminalUpdateColumnChannelNo, TerminalUpdateColumnCityID, TerminalUpdateColumnCreateAt, TerminalUpdateColumnCreateBy, TerminalUpdateColumnDeleteAt, TerminalUpdateColumnDeleteBy, TerminalUpdateColumnDeptID, TerminalUpdateColumnFirstInstallTime, TerminalUpdateColumnGuaranteeDate, TerminalUpdateColumnID, TerminalUpdateColumnImei, TerminalUpdateColumnInstallManID, TerminalUpdateColumnIsDelete, TerminalUpdateColumnIsReg, TerminalUpdateColumnIsSupportPhoto, TerminalUpdateColumnMockAuthKey, TerminalUpdateColumnProduceDate, TerminalUpdateColumnProveProxyrgID, TerminalUpdateColumnProvinceID, TerminalUpdateColumnProxyrgID, TerminalUpdateColumnRecordDate, TerminalUpdateColumnRegID, TerminalUpdateColumnRemarks, TerminalUpdateColumnRemoveReason, TerminalUpdateColumnSimID, TerminalUpdateColumnSprgID, TerminalUpdateColumnTerminalID, TerminalUpdateColumnTypeID, TerminalUpdateColumnUpdateAt, TerminalUpdateColumnUpdateBy, TerminalUpdateColumnVehicleID, TerminalUpdateColumnVersionNumber:
		return true
	}
	return false
}

func (e TerminalUpdateColumn) String() string {
	return string(e)
}

func (e *TerminalUpdateColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TerminalUpdateColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid terminal_update_column", str)
	}
	return nil
}

func (e TerminalUpdateColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
