// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"VehicleSupervision/internal/modules/dictionary/dict/model"
	model1 "VehicleSupervision/pkg/graphql/model"
	"fmt"
	"io"
	"strconv"
	"time"
)

// aggregated selection of "data_dictionary"
type DataDictionaryAggregate struct {
	Aggregate *DataDictionaryAggregateFields `json:"aggregate"`
	Nodes     []*model.DataDictionary        `json:"nodes"`
}

// aggregate fields of "data_dictionary"
type DataDictionaryAggregateFields struct {
	Avg        *DataDictionaryAvgFields        `json:"avg"`
	Count      *int                            `json:"count"`
	Max        *DataDictionaryMaxFields        `json:"max"`
	Min        *DataDictionaryMinFields        `json:"min"`
	Stddev     *DataDictionaryStddevFields     `json:"stddev"`
	StddevPop  *DataDictionaryStddevPopFields  `json:"stddev_pop"`
	StddevSamp *DataDictionaryStddevSampFields `json:"stddev_samp"`
	Sum        *DataDictionarySumFields        `json:"sum"`
	VarPop     *DataDictionaryVarPopFields     `json:"var_pop"`
	VarSamp    *DataDictionaryVarSampFields    `json:"var_samp"`
	Variance   *DataDictionaryVarianceFields   `json:"variance"`
}

// order by aggregate values of table "data_dictionary"
type DataDictionaryAggregateOrderBy struct {
	Avg        *DataDictionaryAvgOrderBy        `json:"avg"`
	Count      *model1.OrderBy                  `json:"count"`
	Max        *DataDictionaryMaxOrderBy        `json:"max"`
	Min        *DataDictionaryMinOrderBy        `json:"min"`
	Stddev     *DataDictionaryStddevOrderBy     `json:"stddev"`
	StddevPop  *DataDictionaryStddevPopOrderBy  `json:"stddev_pop"`
	StddevSamp *DataDictionaryStddevSampOrderBy `json:"stddev_samp"`
	Sum        *DataDictionarySumOrderBy        `json:"sum"`
	VarPop     *DataDictionaryVarPopOrderBy     `json:"var_pop"`
	VarSamp    *DataDictionaryVarSampOrderBy    `json:"var_samp"`
	Variance   *DataDictionaryVarianceOrderBy   `json:"variance"`
}

// input type for inserting array relation for remote table "data_dictionary"
type DataDictionaryArrRelInsertInput struct {
	Data       []*DataDictionaryInsertInput `json:"data"`
	OnConflict *DataDictionaryOnConflict    `json:"on_conflict"`
}

// aggregate avg on columns
type DataDictionaryAvgFields struct {
	ID    *float64 `json:"id"`
	Value *float64 `json:"value"`
}

// order by avg() on columns of table "data_dictionary"
type DataDictionaryAvgOrderBy struct {
	ID    *model1.OrderBy `json:"id"`
	Value *model1.OrderBy `json:"value"`
}

// Boolean expression to filter rows from the table "data_dictionary". All fields are combined with a logical 'AND'.
type DataDictionaryBoolExp struct {
	And                  []*DataDictionaryBoolExp         `json:"_and"`
	Not                  *DataDictionaryBoolExp           `json:"_not"`
	Or                   []*DataDictionaryBoolExp         `json:"_or"`
	CreateAt             *model1.TimestamptzComparisonExp `json:"create_at"`
	CreateBy             *model1.StringComparisonExp      `json:"create_by"`
	DeleteAt             *model1.TimestamptzComparisonExp `json:"delete_at"`
	DeleteBy             *model1.StringComparisonExp      `json:"delete_by"`
	DictionaryCategoryID *model1.StringComparisonExp      `json:"dictionary_category_id"`
	DictionaryID         *model1.StringComparisonExp      `json:"dictionary_id"`
	ID                   *model1.BigintComparisonExp      `json:"id"`
	IsDelete             *model1.BooleanComparisonExp     `json:"is_delete"`
	Name                 *model1.StringComparisonExp      `json:"name"`
	Remarks              *model1.StringComparisonExp      `json:"remarks"`
	UpdateAt             *model1.TimestamptzComparisonExp `json:"update_at"`
	UpdateBy             *model1.StringComparisonExp      `json:"update_by"`
	Value                *model1.IntComparisonExp         `json:"value"`
}

// input type for incrementing integer column in table "data_dictionary"
type DataDictionaryIncInput struct {
	ID    *int64 `json:"id"`
	Value *int   `json:"value"`
}

// input type for inserting data into table "data_dictionary"
type DataDictionaryInsertInput struct {
	CreateAt             *time.Time `json:"create_at"`
	CreateBy             *string    `json:"create_by"`
	DeleteAt             *time.Time `json:"delete_at"`
	DeleteBy             *string    `json:"delete_by"`
	DictionaryCategoryID *string    `json:"dictionary_category_id"`
	DictionaryID         *string    `json:"dictionary_id"`
	ID                   *int64     `json:"id"`
	IsDelete             *bool      `json:"is_delete"`
	Name                 *string    `json:"name"`
	Remarks              *string    `json:"remarks"`
	UpdateAt             *time.Time `json:"update_at"`
	UpdateBy             *string    `json:"update_by"`
	Value                *int       `json:"value"`
}

// aggregate max on columns
type DataDictionaryMaxFields struct {
	CreateAt             *time.Time `json:"create_at"`
	CreateBy             *string    `json:"create_by"`
	DeleteAt             *time.Time `json:"delete_at"`
	DeleteBy             *string    `json:"delete_by"`
	DictionaryCategoryID *string    `json:"dictionary_category_id"`
	DictionaryID         *string    `json:"dictionary_id"`
	ID                   *int64     `json:"id"`
	Name                 *string    `json:"name"`
	Remarks              *string    `json:"remarks"`
	UpdateAt             *time.Time `json:"update_at"`
	UpdateBy             *string    `json:"update_by"`
	Value                *int       `json:"value"`
}

// order by max() on columns of table "data_dictionary"
type DataDictionaryMaxOrderBy struct {
	CreateAt             *model1.OrderBy `json:"create_at"`
	CreateBy             *model1.OrderBy `json:"create_by"`
	DeleteAt             *model1.OrderBy `json:"delete_at"`
	DeleteBy             *model1.OrderBy `json:"delete_by"`
	DictionaryCategoryID *model1.OrderBy `json:"dictionary_category_id"`
	DictionaryID         *model1.OrderBy `json:"dictionary_id"`
	ID                   *model1.OrderBy `json:"id"`
	Name                 *model1.OrderBy `json:"name"`
	Remarks              *model1.OrderBy `json:"remarks"`
	UpdateAt             *model1.OrderBy `json:"update_at"`
	UpdateBy             *model1.OrderBy `json:"update_by"`
	Value                *model1.OrderBy `json:"value"`
}

// aggregate min on columns
type DataDictionaryMinFields struct {
	CreateAt             *time.Time `json:"create_at"`
	CreateBy             *string    `json:"create_by"`
	DeleteAt             *time.Time `json:"delete_at"`
	DeleteBy             *string    `json:"delete_by"`
	DictionaryCategoryID *string    `json:"dictionary_category_id"`
	DictionaryID         *string    `json:"dictionary_id"`
	ID                   *int64     `json:"id"`
	Name                 *string    `json:"name"`
	Remarks              *string    `json:"remarks"`
	UpdateAt             *time.Time `json:"update_at"`
	UpdateBy             *string    `json:"update_by"`
	Value                *int       `json:"value"`
}

// order by min() on columns of table "data_dictionary"
type DataDictionaryMinOrderBy struct {
	CreateAt             *model1.OrderBy `json:"create_at"`
	CreateBy             *model1.OrderBy `json:"create_by"`
	DeleteAt             *model1.OrderBy `json:"delete_at"`
	DeleteBy             *model1.OrderBy `json:"delete_by"`
	DictionaryCategoryID *model1.OrderBy `json:"dictionary_category_id"`
	DictionaryID         *model1.OrderBy `json:"dictionary_id"`
	ID                   *model1.OrderBy `json:"id"`
	Name                 *model1.OrderBy `json:"name"`
	Remarks              *model1.OrderBy `json:"remarks"`
	UpdateAt             *model1.OrderBy `json:"update_at"`
	UpdateBy             *model1.OrderBy `json:"update_by"`
	Value                *model1.OrderBy `json:"value"`
}

// response of any mutation on the table "data_dictionary"
type DataDictionaryMutationResponse struct {
	// number of affected rows by the mutation
	AffectedRows int `json:"affected_rows"`
	// data of the affected rows by the mutation
	Returning []*model.DataDictionary `json:"returning"`
}

// input type for inserting object relation for remote table "data_dictionary"
type DataDictionaryObjRelInsertInput struct {
	Data       *DataDictionaryInsertInput `json:"data"`
	OnConflict *DataDictionaryOnConflict  `json:"on_conflict"`
}

// on conflict condition type for table "data_dictionary"
type DataDictionaryOnConflict struct {
	Constraint    DataDictionaryConstraint     `json:"constraint"`
	UpdateColumns []DataDictionaryUpdateColumn `json:"update_columns"`
	Where         *DataDictionaryBoolExp       `json:"where"`
}

// ordering options when selecting data from "data_dictionary"
type DataDictionaryOrderBy struct {
	CreateAt             *model1.OrderBy `json:"create_at"`
	CreateBy             *model1.OrderBy `json:"create_by"`
	DeleteAt             *model1.OrderBy `json:"delete_at"`
	DeleteBy             *model1.OrderBy `json:"delete_by"`
	DictionaryCategoryID *model1.OrderBy `json:"dictionary_category_id"`
	DictionaryID         *model1.OrderBy `json:"dictionary_id"`
	ID                   *model1.OrderBy `json:"id"`
	IsDelete             *model1.OrderBy `json:"is_delete"`
	Name                 *model1.OrderBy `json:"name"`
	Remarks              *model1.OrderBy `json:"remarks"`
	UpdateAt             *model1.OrderBy `json:"update_at"`
	UpdateBy             *model1.OrderBy `json:"update_by"`
	Value                *model1.OrderBy `json:"value"`
}

// primary key columns input for table: "data_dictionary"
type DataDictionaryPkColumnsInput struct {
	// ID
	ID int64 `json:"id"`
}

// input type for updating data in table "data_dictionary"
type DataDictionarySetInput struct {
	CreateAt             *time.Time `json:"create_at"`
	CreateBy             *string    `json:"create_by"`
	DeleteAt             *time.Time `json:"delete_at"`
	DeleteBy             *string    `json:"delete_by"`
	DictionaryCategoryID *string    `json:"dictionary_category_id"`
	DictionaryID         *string    `json:"dictionary_id"`
	ID                   *int64     `json:"id"`
	IsDelete             *bool      `json:"is_delete"`
	Name                 *string    `json:"name"`
	Remarks              *string    `json:"remarks"`
	UpdateAt             *time.Time `json:"update_at"`
	UpdateBy             *string    `json:"update_by"`
	Value                *int       `json:"value"`
}

// aggregate stddev on columns
type DataDictionaryStddevFields struct {
	ID    *float64 `json:"id"`
	Value *float64 `json:"value"`
}

// order by stddev() on columns of table "data_dictionary"
type DataDictionaryStddevOrderBy struct {
	ID    *model1.OrderBy `json:"id"`
	Value *model1.OrderBy `json:"value"`
}

// aggregate stddev_pop on columns
type DataDictionaryStddevPopFields struct {
	ID    *float64 `json:"id"`
	Value *float64 `json:"value"`
}

// order by stddev_pop() on columns of table "data_dictionary"
type DataDictionaryStddevPopOrderBy struct {
	ID    *model1.OrderBy `json:"id"`
	Value *model1.OrderBy `json:"value"`
}

// aggregate stddev_samp on columns
type DataDictionaryStddevSampFields struct {
	ID    *float64 `json:"id"`
	Value *float64 `json:"value"`
}

// order by stddev_samp() on columns of table "data_dictionary"
type DataDictionaryStddevSampOrderBy struct {
	ID    *model1.OrderBy `json:"id"`
	Value *model1.OrderBy `json:"value"`
}

// aggregate sum on columns
type DataDictionarySumFields struct {
	ID    *int64 `json:"id"`
	Value *int   `json:"value"`
}

// order by sum() on columns of table "data_dictionary"
type DataDictionarySumOrderBy struct {
	ID    *model1.OrderBy `json:"id"`
	Value *model1.OrderBy `json:"value"`
}

// aggregate var_pop on columns
type DataDictionaryVarPopFields struct {
	ID    *float64 `json:"id"`
	Value *float64 `json:"value"`
}

// order by var_pop() on columns of table "data_dictionary"
type DataDictionaryVarPopOrderBy struct {
	ID    *model1.OrderBy `json:"id"`
	Value *model1.OrderBy `json:"value"`
}

// aggregate var_samp on columns
type DataDictionaryVarSampFields struct {
	ID    *float64 `json:"id"`
	Value *float64 `json:"value"`
}

// order by var_samp() on columns of table "data_dictionary"
type DataDictionaryVarSampOrderBy struct {
	ID    *model1.OrderBy `json:"id"`
	Value *model1.OrderBy `json:"value"`
}

// aggregate variance on columns
type DataDictionaryVarianceFields struct {
	ID    *float64 `json:"id"`
	Value *float64 `json:"value"`
}

// order by variance() on columns of table "data_dictionary"
type DataDictionaryVarianceOrderBy struct {
	ID    *model1.OrderBy `json:"id"`
	Value *model1.OrderBy `json:"value"`
}

// subscription root
type SubscriptionRoot struct {
	// fetch data from the table: "data_dictionary"
	DataDictionary []*model.DataDictionary `json:"data_dictionary"`
	// fetch aggregated fields from the table: "data_dictionary"
	DataDictionaryAggregate *DataDictionaryAggregate `json:"data_dictionary_aggregate"`
	// fetch data from the table: "data_dictionary" using primary key columns
	DataDictionaryByPk *model.DataDictionary `json:"data_dictionary_by_pk"`
}

// unique or primary key constraints on table "data_dictionary"
type DataDictionaryConstraint string

const (
	// unique or primary key constraint
	DataDictionaryConstraintDataDirtionaryPkey DataDictionaryConstraint = "data_dirtionary_pkey"
)

var AllDataDictionaryConstraint = []DataDictionaryConstraint{
	DataDictionaryConstraintDataDirtionaryPkey,
}

func (e DataDictionaryConstraint) IsValid() bool {
	switch e {
	case DataDictionaryConstraintDataDirtionaryPkey:
		return true
	}
	return false
}

func (e DataDictionaryConstraint) String() string {
	return string(e)
}

func (e *DataDictionaryConstraint) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DataDictionaryConstraint(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid data_dictionary_constraint", str)
	}
	return nil
}

func (e DataDictionaryConstraint) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// select columns of table "data_dictionary"
type DataDictionarySelectColumn string

const (
	// column name
	DataDictionarySelectColumnCreateAt DataDictionarySelectColumn = "create_at"
	// column name
	DataDictionarySelectColumnCreateBy DataDictionarySelectColumn = "create_by"
	// column name
	DataDictionarySelectColumnDeleteAt DataDictionarySelectColumn = "delete_at"
	// column name
	DataDictionarySelectColumnDeleteBy DataDictionarySelectColumn = "delete_by"
	// column name
	DataDictionarySelectColumnDictionaryCategoryID DataDictionarySelectColumn = "dictionary_category_id"
	// column name
	DataDictionarySelectColumnDictionaryID DataDictionarySelectColumn = "dictionary_id"
	// column name
	DataDictionarySelectColumnID DataDictionarySelectColumn = "id"
	// column name
	DataDictionarySelectColumnIsDelete DataDictionarySelectColumn = "is_delete"
	// column name
	DataDictionarySelectColumnName DataDictionarySelectColumn = "name"
	// column name
	DataDictionarySelectColumnRemarks DataDictionarySelectColumn = "remarks"
	// column name
	DataDictionarySelectColumnUpdateAt DataDictionarySelectColumn = "update_at"
	// column name
	DataDictionarySelectColumnUpdateBy DataDictionarySelectColumn = "update_by"
	// column name
	DataDictionarySelectColumnValue DataDictionarySelectColumn = "value"
)

var AllDataDictionarySelectColumn = []DataDictionarySelectColumn{
	DataDictionarySelectColumnCreateAt,
	DataDictionarySelectColumnCreateBy,
	DataDictionarySelectColumnDeleteAt,
	DataDictionarySelectColumnDeleteBy,
	DataDictionarySelectColumnDictionaryCategoryID,
	DataDictionarySelectColumnDictionaryID,
	DataDictionarySelectColumnID,
	DataDictionarySelectColumnIsDelete,
	DataDictionarySelectColumnName,
	DataDictionarySelectColumnRemarks,
	DataDictionarySelectColumnUpdateAt,
	DataDictionarySelectColumnUpdateBy,
	DataDictionarySelectColumnValue,
}

func (e DataDictionarySelectColumn) IsValid() bool {
	switch e {
	case DataDictionarySelectColumnCreateAt, DataDictionarySelectColumnCreateBy, DataDictionarySelectColumnDeleteAt, DataDictionarySelectColumnDeleteBy, DataDictionarySelectColumnDictionaryCategoryID, DataDictionarySelectColumnDictionaryID, DataDictionarySelectColumnID, DataDictionarySelectColumnIsDelete, DataDictionarySelectColumnName, DataDictionarySelectColumnRemarks, DataDictionarySelectColumnUpdateAt, DataDictionarySelectColumnUpdateBy, DataDictionarySelectColumnValue:
		return true
	}
	return false
}

func (e DataDictionarySelectColumn) String() string {
	return string(e)
}

func (e *DataDictionarySelectColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DataDictionarySelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid data_dictionary_select_column", str)
	}
	return nil
}

func (e DataDictionarySelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// update columns of table "data_dictionary"
type DataDictionaryUpdateColumn string

const (
	// column name
	DataDictionaryUpdateColumnCreateAt DataDictionaryUpdateColumn = "create_at"
	// column name
	DataDictionaryUpdateColumnCreateBy DataDictionaryUpdateColumn = "create_by"
	// column name
	DataDictionaryUpdateColumnDeleteAt DataDictionaryUpdateColumn = "delete_at"
	// column name
	DataDictionaryUpdateColumnDeleteBy DataDictionaryUpdateColumn = "delete_by"
	// column name
	DataDictionaryUpdateColumnDictionaryCategoryID DataDictionaryUpdateColumn = "dictionary_category_id"
	// column name
	DataDictionaryUpdateColumnDictionaryID DataDictionaryUpdateColumn = "dictionary_id"
	// column name
	DataDictionaryUpdateColumnID DataDictionaryUpdateColumn = "id"
	// column name
	DataDictionaryUpdateColumnIsDelete DataDictionaryUpdateColumn = "is_delete"
	// column name
	DataDictionaryUpdateColumnName DataDictionaryUpdateColumn = "name"
	// column name
	DataDictionaryUpdateColumnRemarks DataDictionaryUpdateColumn = "remarks"
	// column name
	DataDictionaryUpdateColumnUpdateAt DataDictionaryUpdateColumn = "update_at"
	// column name
	DataDictionaryUpdateColumnUpdateBy DataDictionaryUpdateColumn = "update_by"
	// column name
	DataDictionaryUpdateColumnValue DataDictionaryUpdateColumn = "value"
)

var AllDataDictionaryUpdateColumn = []DataDictionaryUpdateColumn{
	DataDictionaryUpdateColumnCreateAt,
	DataDictionaryUpdateColumnCreateBy,
	DataDictionaryUpdateColumnDeleteAt,
	DataDictionaryUpdateColumnDeleteBy,
	DataDictionaryUpdateColumnDictionaryCategoryID,
	DataDictionaryUpdateColumnDictionaryID,
	DataDictionaryUpdateColumnID,
	DataDictionaryUpdateColumnIsDelete,
	DataDictionaryUpdateColumnName,
	DataDictionaryUpdateColumnRemarks,
	DataDictionaryUpdateColumnUpdateAt,
	DataDictionaryUpdateColumnUpdateBy,
	DataDictionaryUpdateColumnValue,
}

func (e DataDictionaryUpdateColumn) IsValid() bool {
	switch e {
	case DataDictionaryUpdateColumnCreateAt, DataDictionaryUpdateColumnCreateBy, DataDictionaryUpdateColumnDeleteAt, DataDictionaryUpdateColumnDeleteBy, DataDictionaryUpdateColumnDictionaryCategoryID, DataDictionaryUpdateColumnDictionaryID, DataDictionaryUpdateColumnID, DataDictionaryUpdateColumnIsDelete, DataDictionaryUpdateColumnName, DataDictionaryUpdateColumnRemarks, DataDictionaryUpdateColumnUpdateAt, DataDictionaryUpdateColumnUpdateBy, DataDictionaryUpdateColumnValue:
		return true
	}
	return false
}

func (e DataDictionaryUpdateColumn) String() string {
	return string(e)
}

func (e *DataDictionaryUpdateColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DataDictionaryUpdateColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid data_dictionary_update_column", str)
	}
	return nil
}

func (e DataDictionaryUpdateColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
